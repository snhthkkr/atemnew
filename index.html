<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="atem">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#000000">
<title>atem</title>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;color:#fff}
#c{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}

/* â”€â”€â”€ Editor overlay â”€â”€â”€ */
#editor{
  position:fixed;display:none;z-index:100;
  left:50%;top:50%;transform:translate(-50%,-50%);
  width:min(340px,88vw);
  background:rgba(10,10,15,0.95);
  border:1px solid rgba(255,255,255,0.12);
  border-radius:16px;padding:16px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
}
#editor.open{display:block}
#editor textarea{
  width:100%;min-height:80px;max-height:200px;
  background:transparent;border:none;outline:none;
  color:#fff;font-size:16px;line-height:1.5;
  font-family:inherit;resize:none;
  -webkit-user-select:text;user-select:text;
}
#editor textarea::placeholder{color:rgba(255,255,255,0.25)}
#ed-color-btn{
  width:20px;height:20px;border-radius:50%;
  border:1.5px solid rgba(255,255,255,0.2);
  cursor:pointer;position:absolute;top:16px;right:16px;
  transition:transform 0.15s;z-index:5;
}
#ed-color-btn:active{transform:scale(0.9)}
#ed-color-palette{
  position:absolute;top:42px;right:16px;
  background:rgba(15,15,20,0.98);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:8px;display:none;gap:6px;
  backdrop-filter:blur(20px);z-index:10;
}
#ed-color-palette.open{display:flex}
.ed-color-swatch{
  width:28px;height:28px;border-radius:50%;cursor:pointer;
  border:2px solid rgba(255,255,255,0.15);transition:transform 0.1s;
}
.ed-color-swatch:active{transform:scale(0.85)}
#ed-folder-row{display:none !important}
.folder-chip{
  padding:4px 10px;border-radius:20px;font-size:12px;
  background:rgba(255,255,255,0.06);color:rgba(255,255,255,0.5);
  border:1px solid rgba(255,255,255,0.08);cursor:pointer;white-space:nowrap;
}
.folder-chip.active{background:rgba(110,168,254,0.2);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.3)}
.folder-chip.add-new{color:rgba(255,255,255,0.3);border-style:dashed}
#ed-folder-input{
  background:transparent;border:none;border-bottom:1px solid rgba(255,255,255,0.2);
  color:#fff;font-size:12px;padding:4px 2px;outline:none;width:80px;
  font-family:inherit;display:none;-webkit-user-select:text;user-select:text;
}
/* session row in editor */
#ed-session-row{
  display:flex;align-items:center;gap:6px;margin-top:6px;padding-top:6px;
  border-top:1px solid rgba(255,255,255,0.04);flex-wrap:wrap;
}
#ed-session-row .s-badge{
  padding:3px 8px;border-radius:12px;font-size:11px;
  background:rgba(110,168,254,0.1);color:rgba(110,168,254,0.7);
  border:1px solid rgba(110,168,254,0.15);
}
#ed-remove-session{
  padding:3px 8px;border-radius:12px;font-size:11px;
  background:rgba(255,100,100,0.08);color:rgba(255,100,100,0.6);
  border:1px solid rgba(255,100,100,0.12);cursor:pointer;
}
#editor-actions{
  display:flex;justify-content:flex-end;gap:8px;
  margin-top:12px;padding-top:12px;
  border-top:1px solid rgba(255,255,255,0.06);
}
#editor-actions button{
  background:rgba(255,255,255,0.08);border:none;
  color:rgba(255,255,255,0.7);font-size:13px;
  padding:6px 14px;border-radius:8px;cursor:pointer;font-family:inherit;
}
#editor-actions button:active{background:rgba(255,255,255,0.15)}
#editor-actions .save{color:#fff;background:rgba(255,255,255,0.15)}
#del-btn{color:rgba(255,100,100,0.8)}

/* â”€â”€â”€ Zero button â”€â”€â”€ */

/* â”€â”€â”€ Folder bar (hidden â€“ sessions replaced folders) â”€â”€â”€ */
#folder-bar{
  position:fixed;
  top:max(38px,calc(env(safe-area-inset-top,0px)+24px));
  left:50%;transform:translateX(-50%);
  display:none !important;gap:6px;z-index:85;
  max-width:calc(100vw - 48px);
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;padding:2px 4px;
}
#folder-bar::-webkit-scrollbar{display:none}
#folder-bar .ftab{
  padding:5px 12px;border-radius:20px;font-size:12px;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.3);
  border:1px solid rgba(255,255,255,0.06);cursor:pointer;
  white-space:nowrap;flex-shrink:0;
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);transition:all 0.2s;
}
#folder-bar .ftab:active{background:rgba(255,255,255,0.08)}
#folder-bar .ftab.active{background:rgba(110,168,254,0.15);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.25)}

/* â”€â”€â”€ Session indicator (top center) â”€â”€â”€ */
/* â”€â”€â”€ Tag bar (hover to reveal) â”€â”€â”€ */
#tag-bar{
  position:fixed;top:0;left:0;right:0;
  background:rgba(10,10,15,0.95);backdrop-filter:blur(20px);
  padding:10px 16px;display:flex;gap:8px;align-items:center;
  z-index:100;transform:translateY(-100%);transition:transform 0.2s;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
#tag-bar.show{transform:translateY(0)}
.tag-chip{
  padding:5px 11px;border-radius:16px;font-size:12px;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.4);
  border:1px solid rgba(255,255,255,0.08);cursor:pointer;
  white-space:nowrap;transition:all 0.15s;
}
.tag-chip:hover{background:rgba(255,255,255,0.08)}
.tag-chip.active{background:rgba(110,168,254,0.15);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.3)}
.tag-chip.add-new{border-style:dashed;color:rgba(110,168,254,0.5)}

/* â”€â”€â”€ Session drawer button (bottom-right) â”€â”€â”€ */
#session-btn{
  position:fixed;
  bottom:40px;
  left:50%;
  transform:translateX(-50%);
  width:56px;height:56px;border-radius:50%;
  background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.3);
  display:flex !important;align-items:center;justify-content:center;
  cursor:pointer;z-index:9999;touch-action:manipulation;
  -webkit-tap-highlight-color:transparent;
}
#session-btn:active{background:rgba(255,255,255,0.2)}
#session-btn svg{width:18px;height:18px;opacity:0.7;pointer-events:none}
#session-badge{
  position:absolute;top:-3px;right:-3px;
  min-width:14px;height:14px;border-radius:7px;
  background:rgba(110,168,254,0.8);color:#000;
  font-size:9px;font-weight:600;
  display:none;align-items:center;justify-content:center;padding:0 3px;
}
#session-badge.on{display:flex}

/* â”€â”€â”€ Session drawer (slide from left) â”€â”€â”€ */
#session-scrim{
  position:fixed;inset:0;z-index:9989;display:none;background:rgba(0,0,0,0.4);
}
#session-scrim.open{display:block}
#session-drawer{
  position:fixed;top:0;left:0;bottom:0;
  width:min(280px,80vw);
  background:rgba(10,10,15,0.97);
  border-right:1px solid rgba(255,255,255,0.08);
  z-index:9990;
  transform:translateX(-100%);
  transition:transform 0.25s cubic-bezier(0.32,0.72,0,1);
  display:flex;flex-direction:column;
  padding:max(16px,env(safe-area-inset-top,0px)) 0 max(16px,env(safe-area-inset-bottom,0px));
  overflow-y:auto;-webkit-overflow-scrolling:touch;
}
#session-drawer.open{transform:translateX(0)}
#session-drawer-title{
  font-size:13px;color:rgba(255,255,255,0.3);letter-spacing:0.08em;
  padding:8px 16px 12px;text-transform:uppercase;
}
.sd-item{
  display:flex;align-items:center;gap:10px;
  padding:12px 16px;cursor:pointer;transition:background 0.15s;
  border:none;background:none;width:100%;text-align:left;font-family:inherit;
}
.sd-item:active{background:rgba(255,255,255,0.05)}
.sd-item.active{background:rgba(110,168,254,0.08)}
.sd-thumb{
  width:48px;height:48px;border-radius:8px;
  background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
  flex-shrink:0;
}
.sd-item.active .sd-thumb{border-color:rgba(110,168,254,0.3)}
.sd-info{flex:1;min-width:0}
.sd-name{font-size:14px;color:rgba(255,255,255,0.75);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sd-item.all-item .sd-name{color:rgba(255,255,255,0.45)}
.sd-meta{font-size:11px;color:rgba(255,255,255,0.2);margin-top:2px}
.sd-count{
  font-size:11px;color:rgba(255,255,255,0.2);flex-shrink:0;
  min-width:20px;text-align:right;
}
.sd-rename{
  width:28px;height:28px;border-radius:6px;border:none;
  background:rgba(110,168,254,0.08);color:rgba(110,168,254,0.5);
  font-size:14px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;
  margin-right:6px;
}
.sd-rename:active{background:rgba(110,168,254,0.2)}
.sd-delete{
  width:28px;height:28px;border-radius:6px;border:none;
  background:rgba(255,100,100,0.08);color:rgba(255,100,100,0.5);
  font-size:14px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;
}
.sd-delete:active{background:rgba(255,100,100,0.2)}
#sd-new-session{
  display:flex;align-items:center;gap:8px;
  padding:14px 16px;cursor:pointer;border:none;background:none;
  color:rgba(110,168,254,0.6);font-size:14px;font-family:inherit;
  width:100%;text-align:left;margin-top:auto;
  border-top:1px solid rgba(255,255,255,0.05);
}
#sd-new-session:active{background:rgba(255,255,255,0.03)}
/* â”€â”€â”€ Drawer utility section â”€â”€â”€ */
#sd-utils{
  border-top:1px solid rgba(255,255,255,0.06);
  padding:8px 0 0;margin-top:8px;
}
#sd-utils button{
  display:flex;align-items:center;
  width:100%;text-align:left;background:none;border:none;
  color:rgba(255,255,255,0.4);font-size:13px;
  padding:11px 16px;cursor:pointer;font-family:inherit;
}
#sd-utils button:active{background:rgba(255,255,255,0.05)}
#sd-utils .sd-util-danger{color:rgba(255,100,100,0.5)}
#sd-utils .sd-util-sep{
  margin:4px 16px;font-size:10px;color:rgba(255,255,255,0.12);
  letter-spacing:0.1em;text-transform:uppercase;
}
#sd-utils .toggle-dot{width:7px;height:7px;border-radius:50%;background:rgba(255,255,255,0.15);margin-left:auto;flex-shrink:0}
#sd-utils .toggle-dot.on{background:rgba(110,168,254,0.8)}
/* inline rename input */
.sd-rename-input{
  background:transparent;border:none;border-bottom:1px solid rgba(110,168,254,0.3);
  color:#fff;font-size:14px;padding:0 0 2px;outline:none;width:100%;font-family:inherit;
  -webkit-user-select:text;user-select:text;
}

/* â”€â”€â”€ Connection editor overlay â”€â”€â”€ */
#conn-editor{
  position:fixed;display:none;z-index:120;
  left:50%;top:50%;transform:translate(-50%,-50%);
  width:min(320px,88vw);
  background:rgba(10,10,15,0.96);
  border:1px solid rgba(255,255,255,0.12);
  border-radius:16px;padding:14px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
}
#conn-editor.open{display:block}
#conn-editor-title{font-size:12px;color:rgba(255,255,255,0.3);margin-bottom:10px;letter-spacing:0.05em}
#conn-preset-row{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:10px}
.conn-preset{
  padding:5px 10px;border-radius:14px;font-size:11px;
  border:1px solid rgba(255,255,255,0.1);cursor:pointer;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.5);
  transition:all 0.12s;white-space:nowrap;font-family:inherit;
}
.conn-preset:active{transform:scale(0.95)}
.conn-preset.active{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.9);background:rgba(255,255,255,0.08)}
#conn-custom-input{
  width:100%;background:transparent;border:none;
  border-bottom:1px solid rgba(255,255,255,0.1);
  color:#fff;font-size:13px;padding:6px 0;outline:none;
  font-family:inherit;margin-bottom:10px;
  -webkit-user-select:text;user-select:text;
}
#conn-custom-input::placeholder{color:rgba(255,255,255,0.2)}
#conn-color-row{display:flex;gap:6px;margin-bottom:12px;align-items:center}
#conn-color-row .conn-cswatch{
  width:22px;height:22px;border-radius:50%;cursor:pointer;
  border:2px solid rgba(255,255,255,0.1);transition:transform 0.1s;
}
#conn-color-row .conn-cswatch:active{transform:scale(0.85)}
#conn-color-row .conn-cswatch.active{border-color:rgba(255,255,255,0.5)}
#conn-editor-actions{display:flex;justify-content:flex-end;gap:8px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.06)}
#conn-editor-actions button{
  background:rgba(255,255,255,0.08);border:none;
  color:rgba(255,255,255,0.7);font-size:13px;
  padding:6px 14px;border-radius:8px;cursor:pointer;font-family:inherit;
}
#conn-editor-actions button:active{background:rgba(255,255,255,0.15)}
#conn-editor-actions .conn-del-btn{color:rgba(255,100,100,0.8)}
#conn-editor-actions .conn-done-btn{color:#fff;background:rgba(255,255,255,0.15)}

/* â”€â”€â”€ Thought size buttons in editor â”€â”€â”€ */
#ed-size-row{display:flex;gap:6px;margin-top:8px;align-items:center}
#ed-size-row .size-label{font-size:11px;color:rgba(255,255,255,0.2);margin-right:4px}
.size-btn{
  width:32px;height:26px;border-radius:6px;font-size:11px;font-weight:600;
  border:1px solid rgba(255,255,255,0.08);cursor:pointer;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.35);
  font-family:inherit;transition:all 0.12s;
}
.size-btn:active{transform:scale(0.92)}
.size-btn.active{border-color:rgba(110,168,254,0.4);color:rgba(110,168,254,0.9);background:rgba(110,168,254,0.1)}

/* â”€â”€â”€ Connection delete pill (legacy, kept as fallback) â”€â”€â”€ */
#conn-delete-pill{
  position:fixed;display:none;z-index:110;
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,100,100,0.2);
  border-radius:10px;padding:6px 14px;cursor:pointer;
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  color:rgba(255,100,100,0.8);font-size:13px;font-family:inherit;
  transform:translate(-50%,-100%) translateY(-8px);
}
#conn-delete-pill.open{display:block}
#conn-delete-pill:active{background:rgba(255,50,50,0.15)}

/* â”€â”€â”€ Lasso â”€â”€â”€ */
#lasso-rect{position:fixed;display:none;z-index:70;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.03);pointer-events:none;border-radius:2px}
#lasso-bar{
  position:fixed;display:none;z-index:110;
  bottom:max(80px,calc(env(safe-area-inset-bottom,0px)+70px));
  left:50%;transform:translateX(-50%);
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:6px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);display:none;gap:4px;
}
#lasso-bar.open{display:flex}
#lasso-bar button{
  background:rgba(255,255,255,0.06);border:none;color:rgba(255,255,255,0.7);
  font-size:13px;padding:7px 14px;border-radius:8px;cursor:pointer;font-family:inherit;white-space:nowrap;
}
#lasso-bar button:active{background:rgba(255,255,255,0.12)}
#lasso-folder-picker{
  position:fixed;display:none;z-index:115;
  bottom:max(130px,calc(env(safe-area-inset-bottom,0px)+120px));
  left:50%;transform:translateX(-50%);
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:8px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
  gap:6px;flex-wrap:wrap;max-width:80vw;justify-content:center;
}
#lasso-folder-picker.open{display:flex}

/* â”€â”€â”€ Stats (hidden â€“ vanity metric) â”€â”€â”€ */
#stats{
  display:none;
}
/* â”€â”€â”€ FPS â”€â”€â”€ */
#fps{
  position:fixed;top:max(16px,env(safe-area-inset-top,0px));right:16px;
  font-size:10px;color:rgba(255,255,255,0.2);
  font-variant-numeric:tabular-nums;pointer-events:none;display:none;z-index:85;
}
#fps.on{display:block}

/* â”€â”€â”€ Tray button (hidden â€“ merged into session drawer) â”€â”€â”€ */
#tray-btn{
  display:none !important;
}
#tray-btn svg{width:16px;height:16px;opacity:0.5;pointer-events:none}
/* â”€â”€â”€ Tray sheet (hidden â€“ merged into session drawer) â”€â”€â”€ */
#tray{
  display:none !important;
}
#tray.open{transform:translateY(0)}
#tray-handle{width:36px;height:4px;border-radius:2px;background:rgba(255,255,255,0.15);margin:0 auto 16px}
#tray button{
  display:flex;align-items:center;justify-content:space-between;
  width:100%;text-align:left;background:none;border:none;
  color:rgba(255,255,255,0.75);font-size:15px;
  padding:13px 12px;border-radius:10px;cursor:pointer;font-family:inherit;
}
#tray button:active{background:rgba(255,255,255,0.07)}
.toggle-dot{width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.15);flex-shrink:0}
.toggle-dot.on{background:rgba(110,168,254,0.8)}
.tray-sep{margin:4px 12px;font-size:10px;color:rgba(255,255,255,0.15);letter-spacing:0.1em;text-transform:uppercase}
#tray-scrim{position:fixed;inset:0;z-index:9998;display:none;background:transparent}
#tray-scrim.open{display:block}

/* â”€â”€â”€ Hint â”€â”€â”€ */
#hint{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:rgba(255,255,255,0.08);font-size:14px;pointer-events:none;transition:opacity 0.8s ease}
/* â”€â”€â”€ Toast â”€â”€â”€ */
#toast{
  position:fixed;top:max(16px,env(safe-area-inset-top,0px));
  left:50%;transform:translateX(-50%) translateY(-40px);
  background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.1);
  border-radius:10px;padding:8px 16px;color:rgba(255,255,255,0.7);font-size:13px;
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
  opacity:0;transition:all 0.3s ease;z-index:200;pointer-events:none;
}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">tap anywhere</div>

<!-- Editor -->
<div id="editor">
  <textarea id="ed-text" placeholder="think..." autocomplete="off" autocorrect="on" spellcheck="true"></textarea>
  <button id="ed-color-btn" title="change color"></button>
  <div id="ed-color-palette"></div>
  <div id="ed-size-row">
    <span class="size-label">size</span>
    <button class="size-btn" data-size="0.6">S</button>
    <button class="size-btn" data-size="1.0">M</button>
    <button class="size-btn" data-size="1.5">L</button>
  </div>
  <div id="ed-session-row"></div>
  <div id="editor-actions">
    <button id="del-btn">delete</button>
    <button id="cancel-btn">cancel</button>
    <button class="save" id="save-btn">done</button>
  </div>
</div>

<!-- Connection editor -->
<div id="conn-editor">
  <div id="conn-editor-title">connection</div>
  <div id="conn-preset-row"></div>
  <input id="conn-custom-input" type="text" placeholder="or type your own..." autocomplete="off">
  <div id="conn-color-row"></div>
  <div id="conn-editor-actions">
    <button class="conn-del-btn" id="conn-del-btn">remove</button>
    <button class="conn-done-btn" id="conn-done-btn">done</button>
  </div>
</div>

<!-- Tag bar (hover top to reveal) -->
<div id="tag-bar"></div>

<!-- Drawer button (bottom-right, permanent) -->
<button id="session-btn">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <line x1="4" y1="8" x2="20" y2="8"/>
    <line x1="4" y1="12" x2="20" y2="12"/>
    <line x1="4" y1="16" x2="20" y2="16"/>
  </svg>
  <span id="session-badge"></span>
</button>

<!-- Session drawer -->
<div id="session-scrim"></div>
<div id="session-drawer">
  <div id="session-drawer-title">tags</div>
  <div id="sd-list"></div>
  <button id="sd-new-session">+ new tag</button>
  
  <div class="sd-util-sep">utilities</div>
  <button id="sd-export">ðŸ’¾ export</button>
  <button id="sd-import">ðŸ“‚ import</button>
  <button id="sd-migrate">ðŸ“¦ move all to Session 1</button>
  <button id="sd-open-capture">open to capture <span class="toggle-dot" id="sd-capture-dot"></span></button>
  
  <div id="sd-utils">
    <div class="sd-util-sep">dev tools</div>
    <button id="sd-test-thought">+ test thought</button>
    <button id="sd-bulk-test">+ bulk test (100/500/1k)</button>
    <button id="sd-clean-connections">ðŸ”§ clean orphaned connections</button>
    <button id="sd-reset-view">reset camera</button>
    <button id="sd-show-orphans">highlight orphans</button>
    <button id="sd-toggle-fps">fps <span class="toggle-dot" id="sd-fps-dot"></span></button>
    <button id="sd-dump-state">dump state</button>
    <button id="sd-force-save">force save</button>
    <div class="sd-util-sep"></div>
    <button id="sd-clear" class="sd-util-danger">âš  clear all</button>
  </div>
</div>

<!-- Folder bar -->
<div id="folder-bar"></div>
<!-- Connection delete pill -->
<div id="conn-delete-pill">remove</div>
<!-- Lasso -->
<div id="lasso-rect"></div>
<div id="lasso-bar">
  <button id="lasso-new-session-btn">new session</button>
  <button id="lasso-recolor-btn">recolor</button>
  <button id="lasso-clear-btn">clear</button>
</div>
<!-- Stats -->
<div id="stats"></div>
<!-- FPS -->
<div id="fps"></div>
<!-- Tray -->
<button id="tray-btn" aria-label="menu">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <line x1="4" y1="7" x2="20" y2="7"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="17" x2="20" y2="17"/>
  </svg>
</button>
<div id="tray-scrim"></div>
<div id="tray" role="menu">
  <div id="tray-handle"></div>
  <button id="btn-export">export thoughts</button>
  <button id="btn-import">import thoughts</button>
  <button id="btn-open-capture">open to capture <span class="toggle-dot" id="capture-toggle-dot"></span></button>
  <button id="btn-clear">clear all</button>
  <div class="tray-sep">dev</div>
  <button id="btn-reset-view">reset camera</button>
  <button id="btn-dump-state">dump state</button>
  <button id="btn-force-save">force save</button>
  <button id="btn-show-orphans">show orphans</button>
  <button id="btn-toggle-fps">fps counter <span class="toggle-dot" id="fps-dot"></span></button>
</div>
<div id="toast"></div>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/","idb-keyval":"https://cdn.jsdelivr.net/npm/idb-keyval@6/+esm"}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { get, set, del } from 'idb-keyval';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let state = {
  version: 13,         // v13: IndexedDB + performance fixes
  thoughts: [], connections: [], folders: [],
  activeFolder: null, camera: null, openToCapture: false,
  sessions: [],        // v5: array of session objects
  activeSession: null  // v5: session ID or null
};

const SESSION_THRESHOLD = 15;

let editingId = null, editingFolder = null, editingColor = null, editingSize = 1.0;
let connectSource = null, holdTimer = null;
let isDragging = false, draggedMesh = null;
let dragOffset = new THREE.Vector3();
let pointerStart = { x:0, y:0 }, pointerMoved = false, holdTriggered = false;
let pendingLineMesh = null, hintVisible = true;
let showFps = false;
let lassoActive = false, lassoStart = null, lassoEnd = null;
let lassoHoldTimer = null, lassoHoldTriggered = false;
let selectedIds = new Set();
let pendingDeleteConnId = null;
let sessionTipShown = false;

const HOLD_MS = 350, DRAG_THRESH = 8, SPHERE_RADIUS = 0.35;
const raycaster = new THREE.Raycaster();
raycaster.params.Line = { threshold: 0.4 };
const pointer = new THREE.Vector2();
const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
const intersectPt = new THREE.Vector3();
const COLORS = ['#6ea8fe','#a78bfa','#f472b6','#34d399','#fbbf24','#fb923c','#f87171','#67e8f9'];
let colorIdx = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Scene
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.035);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 0, 18);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enablePan = true; controls.panSpeed = 0.8;
controls.rotateSpeed = 0.5; controls.zoomSpeed = 0.8;
controls.minDistance = 0.5; controls.maxDistance = 200;
controls.addEventListener('change', () => { needsRender = true; });

scene.add(new THREE.AmbientLight(0x404060, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,8,10); scene.add(dl);
const bl = new THREE.DirectionalLight(0x4466aa, 0.3); bl.position.set(-5,-3,-8); scene.add(bl);

const sg = new THREE.BufferGeometry(); const sv = [];
for(let i=0;i<400;i++) sv.push((Math.random()-.5)*100,(Math.random()-.5)*100,(Math.random()-.5)*100);
sg.setAttribute('position', new THREE.Float32BufferAttribute(sv,3));
scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff,size:0.08,transparent:true,opacity:0.3})));

const thoughtGroup = new THREE.Group(); scene.add(thoughtGroup);
const lineGroup = new THREE.Group(); scene.add(lineGroup);

// Lookup maps for O(1) access
const thoughtMap = new Map();
const meshMap = new Map();
function rebuildMaps() {
  thoughtMap.clear(); meshMap.clear();
  for (const t of state.thoughts) thoughtMap.set(t.id, t);
  for (const m of thoughtGroup.children) meshMap.set(m.userData.id, m);
}

// Connection presets
const CONN_PRESETS = [
  { label:'causes', color:'#fb923c' },
  { label:'contradicts', color:'#f87171' },
  { label:'supports', color:'#34d399' },
  { label:'depends on', color:'#fbbf24' },
  { label:'relates to', color:'#6ea8fe' },
  { label:'reminds me of', color:'#a78bfa' },
  { label:'same as', color:'#67e8f9' },
  { label:'part of', color:'#f472b6' },
  { label:'leads to', color:'#fb923c' },
  { label:'follows from', color:'#fbbf24' },
];
const CONN_COLORS = ['#6ea8fe','#fb923c','#f87171','#34d399','#fbbf24','#a78bfa','#f472b6','#67e8f9'];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Thought mesh
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 24, 18);

function makeThoughtMaterial(color) {
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(color||'#6ea8fe'),
    emissive: new THREE.Color(color||'#6ea8fe'),
    emissiveIntensity:0.15, roughness:0.4, metalness:0.1,
    transparent:true, opacity:0.9,
  });
}

function createLabel(text) {
  const c = document.createElement('canvas');
  c.width = 1024; c.height = 256;
  const ctx = c.getContext('2d');
  ctx.scale(2, 2);
  ctx.clearRect(0, 0, 512, 128);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
  ctx.font = '300 24px -apple-system, BlinkMacSystemFont, sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  let display = text || '';
  if (display.length > 50) display = display.slice(0, 48) + 'â€¦';
  const words = display.split(' ');
  let lines = [], line = '';
  for (const w of words) {
    const test = line ? line+' '+w : w;
    if (ctx.measureText(test).width > 460) { lines.push(line); line = w; }
    else line = test;
  }
  if (line) lines.push(line);
  if (lines.length > 3) lines = lines.slice(0,3);
  const lineH = 30;
  const startY = 64 - ((lines.length-1)*lineH)/2;
  lines.forEach((l,i) => ctx.fillText(l, 256, startY + i*lineH));
  const tex = new THREE.CanvasTexture(c); tex.needsUpdate = true;
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, opacity:0.85, depthTest:false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(3, 0.75, 1);
  sprite.position.y = -SPHERE_RADIUS - 0.5;
  return sprite;
}

function addThoughtMesh(t) {
  const mat = makeThoughtMaterial(t.color);
  const mesh = new THREE.Mesh(sphereGeo, mat);
  mesh.position.set(t.position[0], t.position[1], t.position[2]);
  mesh.userData = { id:t.id, baseEmissive:0.15, targetEmissive:0.15, targetOpacity:0.9, breath:Math.random()*Math.PI*2 };
  const size = t.size || 1.0;
  mesh.scale.setScalar(size);
  if (t.text) { const l = createLabel(t.text); l.name='label'; mesh.add(l); }
  thoughtGroup.add(mesh);
  meshMap.set(t.id, mesh);
  return mesh;
}

function updateLabel(mesh, text) {
  const old = mesh.getObjectByName('label');
  if (old) mesh.remove(old);
  if (text) { const l = createLabel(text); l.name='label'; mesh.add(l); }
}

function getMesh(id) { return meshMap.get(id) || thoughtGroup.children.find(m => m.userData.id === id); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Connections
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function createSmallLabel(text, color) {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 128;
  const ctx = c.getContext('2d');
  ctx.scale(2, 2);
  ctx.clearRect(0, 0, 256, 64);
  ctx.fillStyle = color || 'rgba(255,255,255,0.55)';
  ctx.font = '500 16px -apple-system, BlinkMacSystemFont, sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  let display = text || '';
  if (display.length > 24) display = display.slice(0, 22) + 'â€¦';
  ctx.fillText(display, 128, 32);
  const tex = new THREE.CanvasTexture(c); tex.needsUpdate = true;
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, opacity:0.7, depthTest:false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(2.0, 0.5, 1);
  return sprite;
}

function rebuildConnections() {
  while (lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  const pairs = {};
  for (const c of state.connections) { const key = [c.from, c.to].sort().join('|'); pairs[key] = (pairs[key]||0) + 1; }
  const drawn = new Set();
  for (const c of state.connections) {
    const key = [c.from, c.to].sort().join('|');
    if (drawn.has(key)) continue; drawn.add(key);
    const mA = getMesh(c.from), mB = getMesh(c.to);
    if (!mA || !mB) continue;
    const density = pairs[key]||1;
    const connColor = c.color || '#6ea8fe';
    const baseOpacity = Math.min(0.35 + density*0.1, 0.75);
    const geo = new THREE.BufferGeometry().setFromPoints([mA.position.clone(), mB.position.clone()]);
    const mat = new THREE.LineBasicMaterial({ color: new THREE.Color(connColor), transparent:true, opacity:baseOpacity, linewidth:1 });
    const line = new THREE.Line(geo, mat);
    const firstConn = state.connections.find(x => [x.from, x.to].sort().join('|') === key);
    line.userData = { from:c.from, to:c.to, density, connKey:key, connId:firstConn?.id, baseOpacity };
    lineGroup.add(line);
    
    // Add midpoint label if connection has a label
    const label = c.label || (density > 1 ? `Ã—${density}` : null);
    if (label) {
      const mid = new THREE.Vector3().addVectors(mA.position, mB.position).multiplyScalar(0.5);
      const sprite = createSmallLabel(label, connColor);
      sprite.position.copy(mid);
      sprite.position.y += 0.25;
      sprite.name = 'conn-label-' + key;
      sprite.userData = { isConnLabel: true, connKey: key };
      lineGroup.add(sprite);
    }
  }
  needsRender = true;
}

function updateConnectionPositions() {
  for (const child of lineGroup.children) {
    if (child.userData.isConnLabel) {
      // Update label midpoint
      const mA = getMesh(child.userData.connKey.split('|')[0]);
      const mB = getMesh(child.userData.connKey.split('|')[1]);
      if (mA && mB) {
        child.position.set(
          (mA.position.x + mB.position.x) / 2,
          (mA.position.y + mB.position.y) / 2 + 0.25,
          (mA.position.z + mB.position.z) / 2
        );
      }
      continue;
    }
    if (!child.userData.from) continue;
    const mA = getMesh(child.userData.from), mB = getMesh(child.userData.to);
    if (!mA || !mB) continue;
    const pos = child.geometry.attributes.position;
    pos.setXYZ(0, mA.position.x, mA.position.y, mA.position.z);
    pos.setXYZ(1, mB.position.x, mB.position.y, mB.position.z);
    pos.needsUpdate = true;
  }
}

pendingLineMesh = (() => {
  const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
  const mat = new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:0.3 });
  const line = new THREE.Line(geo, mat); line.visible = false; scene.add(line); return line;
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session helpers (v5)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getSession(id) { return state.sessions.find(s => s.id === id); }

function getActiveSession() { return state.activeSession ? getSession(state.activeSession) : null; }

function sessionsForThought(tId) {
  return state.sessions.filter(s => s.thoughtIds.has(tId));
}

function isSessionsVisible() { return state.thoughts.length >= SESSION_THRESHOLD; }

function relativeTime(ts) {
  const diff = Date.now() - ts;
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'just now';
  if (mins < 60) return mins + 'm ago';
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return hrs + 'h ago';
  const days = Math.floor(hrs / 24);
  if (days === 1) return 'yesterday';
  if (days < 30) return days + 'd ago';
  return Math.floor(days / 30) + 'mo ago';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Filtering (session + folder)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function isThoughtVisible(t) {
  // Session filter only (folders deprecated)
  if (state.activeSession) {
    const session = getActiveSession();
    if (session && !session.thoughtIds.has(t.id)) return false;
  }
  return true;
}

function applyFilter() {
  for (const mesh of thoughtGroup.children) {
    const t = thoughtMap.get(mesh.userData.id) || state.thoughts.find(x => x.id === mesh.userData.id);
    if (!t) continue;
    const vis = isThoughtVisible(t);
    mesh.userData.targetOpacity = vis ? 0.9 : 0.04;
    mesh.userData.targetEmissive = vis ? 0.15 : 0.02;
    const label = mesh.getObjectByName('label');
    if (label) label.material.opacity = vis ? 0.85 : 0.03;
  }
  for (const child of lineGroup.children) {
    if (child.userData.isConnLabel) {
      // Label sprite â€” match visibility of its connection
      const parts = child.userData.connKey.split('|');
      const tA = thoughtMap.get(parts[0]) || state.thoughts.find(x => x.id === parts[0]);
      const tB = thoughtMap.get(parts[1]) || state.thoughts.find(x => x.id === parts[1]);
      if (!tA || !tB) { child.visible = false; continue; }
      child.visible = isThoughtVisible(tA) && isThoughtVisible(tB);
      continue;
    }
    if (!child.userData.from) continue;
    const tA = thoughtMap.get(child.userData.from) || state.thoughts.find(x => x.id === child.userData.from);
    const tB = thoughtMap.get(child.userData.to) || state.thoughts.find(x => x.id === child.userData.to);
    if (!tA || !tB) { child.visible = false; continue; }
    const bothVisible = isThoughtVisible(tA) && isThoughtVisible(tB);
    child.visible = bothVisible;
    child.material.opacity = bothVisible ? (child.userData.baseOpacity || 0.35) : 0;
  }
  updateSessionUI();
}

function renderFolderBar() {
  // Deprecated - folders removed
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session UI (v5)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateSessionUI() {
  renderTagBar();
  const badge = document.getElementById('session-badge');
  if (state.sessions.length > 1) {
    badge.textContent = state.sessions.length;
    badge.classList.add('on');
  } else {
    badge.classList.remove('on');
  }
}

function renderTagBar() {
  const bar = document.getElementById('tag-bar');
  let html = `<span class="tag-chip${!state.activeSession?' active':''}" data-tag="__all__">all</span>`;
  
  for (const s of state.sessions) {
    const isActive = state.activeSession === s.id;
    html += `<span class="tag-chip${isActive?' active':''}" data-tag="${s.id}">${s.name}</span>`;
  }
  
  html += `<span class="tag-chip add-new" data-tag="__new__">+ tag</span>`;
  bar.innerHTML = html;
  
  // Single delegated click handler
  bar.onclick = (e) => {
    const chip = e.target.closest('.tag-chip');
    if (!chip) return;
    
    const tag = chip.dataset.tag;
    if (tag === '__new__') {
      // Add tag instantly
      const name = `Tag ${state.sessions.length + 1}`;
      const s = createSession(name, []);
      switchSession(s.id);
      renderTagBar();
      toast(`created "${name}" - rename in drawer`);
    } else if (tag === '__all__') {
      switchSession(null);
      renderTagBar();
    } else {
      switchSession(tag);
      renderTagBar();
    }
  };
}

function openSessionDrawer() {
  renderSessionList();
  updateDrawerCaptureToggle();
  document.getElementById('session-drawer').classList.add('open');
  document.getElementById('session-scrim').classList.add('open');
  document.getElementById('tag-bar').classList.remove('show');
}

function closeSessionDrawer() {
  document.getElementById('session-drawer').classList.remove('open');
  document.getElementById('session-scrim').classList.remove('open');
}

function renderSessionList() {
  const list = document.getElementById('sd-list');
  let html = '';
  // "All thoughts" item
  const isAll = !state.activeSession;
  html += `<button class="sd-item all-item${isAll?' active':''}" data-sid="__all__">
    <canvas class="sd-thumb" width="48" height="48"></canvas>
    <span class="sd-info"><span class="sd-name">all thoughts</span></span>
    <span class="sd-count">${state.thoughts.length}</span>
  </button>`;
  // Sessions sorted by touched (most recent first)
  const sorted = [...state.sessions].sort((a,b) => b.touched - a.touched);
  for (const s of sorted) {
    const isActive = state.activeSession === s.id;
    html += `<div class="sd-item${isActive?' active':''}" data-sid="${s.id}">
      <canvas class="sd-thumb" width="48" height="48"></canvas>
      <span class="sd-info">
        <span class="sd-name">${s.name}</span>
        <span class="sd-meta">${relativeTime(s.touched)}</span>
      </span>
      <span class="sd-count">${s.thoughtIds.size}</span>
      <button class="sd-rename" data-rename="${s.id}" title="rename">âœŽ</button>
      <button class="sd-delete" data-del="${s.id}" title="delete">Ã—</button>
    </div>`;
  }
  list.innerHTML = html;

  // Render thumbnails
  renderSessionThumbnails();

  // Events
  list.querySelectorAll('.sd-item[data-sid]').forEach(el => {
    el.addEventListener('click', (e) => {
      if (e.target.closest('.sd-delete') || e.target.closest('.sd-rename')) return;
      const sid = el.dataset.sid;
      switchSession(sid === '__all__' ? null : sid);
      closeSessionDrawer();
    });
  });
  // Rename buttons
  list.querySelectorAll('.sd-rename').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sid = btn.dataset.rename;
      const s = getSession(sid);
      if (!s) return;
      
      const item = btn.closest('.sd-item');
      const nameEl = item.querySelector('.sd-name');
      nameEl.innerHTML = `<input class="sd-rename-input" value="${s.name}" maxlength="30">`;
      const inp = nameEl.querySelector('input');
      inp.focus(); inp.select();
      
      const commit = () => {
        const v = inp.value.trim();
        if (v) { s.name = v; s.touched = Date.now(); save(); }
        renderSessionList();
      };
      inp.addEventListener('blur', commit);
      inp.addEventListener('keydown', (ke) => {
        if (ke.key === 'Enter') { ke.preventDefault(); commit(); }
        if (ke.key === 'Escape') renderSessionList();
      });
    });
  });
  // Delete buttons
  list.querySelectorAll('.sd-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sid = btn.dataset.del;
      const s = getSession(sid);
      if (!s) return;
      
      // Show delete menu if session has thoughts
      if (s.thoughtIds.size > 0) {
        const menu = document.createElement('div');
        menu.style.cssText = `
          position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
          background:rgba(10,10,15,0.98);border:1px solid rgba(255,255,255,0.15);
          border-radius:16px;padding:16px;z-index:200;
          backdrop-filter:blur(20px);min-width:280px;
        `;
        menu.innerHTML = `
          <div style="font-size:14px;color:rgba(255,255,255,0.8);margin-bottom:12px;font-weight:500">Delete "${s.name}"?</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.4);margin-bottom:12px">${s.thoughtIds.size} thoughts</div>
          <button id="del-session-only" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">Delete session only (keep thoughts)</button>
          <button id="del-all" style="width:100%;padding:12px;background:rgba(255,50,50,0.1);border:1px solid rgba(255,50,50,0.2);border-radius:10px;color:rgba(255,100,100,0.9);font-size:13px;cursor:pointer;margin-bottom:12px;font-family:inherit">Delete session + all thoughts</button>
          <button id="del-cancel" style="width:100%;padding:10px;background:transparent;border:none;color:rgba(255,255,255,0.4);font-size:13px;cursor:pointer;font-family:inherit">Cancel</button>
        `;
        document.body.appendChild(menu);
        
        menu.querySelector('#del-session-only').addEventListener('click', () => {
          deleteSession(sid);
          renderSessionList();
          menu.remove();
          toast('session deleted');
        });
        
        menu.querySelector('#del-all').addEventListener('click', () => {
          // Delete all thoughts in session
          const toDelete = Array.from(s.thoughtIds);
          for (const tid of toDelete) {
            const mesh = getMesh(tid);
            if (mesh) thoughtGroup.remove(mesh);
          }
          // Remove thoughts from state
          state.thoughts = state.thoughts.filter(t => !toDelete.includes(t.id));
          // Clean orphaned connections
          state.connections = state.connections.filter(c => {
            const fromExists = state.thoughts.find(t => t.id === c.from);
            const toExists = state.thoughts.find(t => t.id === c.to);
            return fromExists && toExists;
          });
          deleteSession(sid);
          rebuildConnections();
          applyFilter();
          save();
          renderSessionList();
          menu.remove();
          toast(`deleted session + ${toDelete.length} thoughts`);
        });
        
        menu.querySelector('#del-cancel').addEventListener('click', () => menu.remove());
      } else {
        // Empty session - just delete
        deleteSession(sid);
        renderSessionList();
        toast('session deleted');
      }
    });
  });
}

function renderSessionThumbnails() {
  const list = document.getElementById('sd-list');
  const items = list.querySelectorAll('.sd-item');
  
  items.forEach(item => {
    const canvas = item.querySelector('.sd-thumb');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const sid = item.dataset.sid;
    
    // Clear canvas
    ctx.clearRect(0, 0, 48, 48);
    
    // Get thoughts for this session
    let thoughts = [];
    if (sid === '__all__') {
      thoughts = state.thoughts;
    } else {
      const session = getSession(sid);
      if (session) {
        thoughts = state.thoughts.filter(t => session.thoughtIds.has(t.id));
      }
    }
    
    if (thoughts.length === 0) return;
    
    // Find bounds
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    thoughts.forEach(t => {
      minX = Math.min(minX, t.position[0]);
      maxX = Math.max(maxX, t.position[0]);
      minY = Math.min(minY, t.position[1]);
      maxY = Math.max(maxY, t.position[1]);
    });
    
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    const padding = 6;
    
    // Draw thoughts as dots
    thoughts.forEach(t => {
      const x = padding + ((t.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y = padding + ((t.position[1] - minY) / rangeY) * (48 - padding * 2);
      
      ctx.fillStyle = t.color || '#6ea8fe';
      ctx.beginPath();
      ctx.arc(x, y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw connections
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 0.5;
    state.connections.forEach(conn => {
      const tA = thoughts.find(t => t.id === conn.from);
      const tB = thoughts.find(t => t.id === conn.to);
      if (!tA || !tB) return;
      
      const x1 = padding + ((tA.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y1 = padding + ((tA.position[1] - minY) / rangeY) * (48 - padding * 2);
      const x2 = padding + ((tB.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y2 = padding + ((tB.position[1] - minY) / rangeY) * (48 - padding * 2);
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    });
  });
}

function switchSession(sessionId) {
  state.activeSession = sessionId;
  if (sessionId) {
    const s = getSession(sessionId);
    if (s) s.touched = Date.now();
  }
  applyFilter(); save();
}

// Camera flight disabled - was causing zoom issues
function frameSessionThoughts(sessionId) {
  // Disabled for stability
}

function flyToPosition(x, y, z) {
  // Disabled for stability
}

function createSession(name, thoughtIds) {
  // Assign a hue and position based on session count
  const hue = (state.sessions.length * 137.5) % 360; // golden angle
  
  // Fibonacci sphere for even 3D distribution
  const i = state.sessions.length;
  const phi = Math.acos(1 - 2 * (i + 0.5) / Math.max(1, state.sessions.length + 1));
  const theta = Math.PI * (1 + Math.sqrt(5)) * i;
  const radius = 25; // distance from origin
  
  const s = {
    id: uid(),
    name: name || `Session ${state.sessions.length + 1}`,
    thoughtIds: new Set(thoughtIds || []),
    hue: hue,
    position: [
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta),
      radius * Math.cos(phi)
    ],
    created: Date.now(),
    touched: Date.now()
  };
  state.sessions.push(s);
  save();
  return s;
}

function deleteSession(sid) {
  state.sessions = state.sessions.filter(s => s.id !== sid);
  if (state.activeSession === sid) state.activeSession = null;
  applyFilter(); save();
}

// Session button â€” touchend for iOS PWA (click not reliably synthesised over
// a full-screen canvas with touch-action:none); click retained for mouse/desktop.
const sessionBtnEl = document.getElementById('session-btn');
sessionBtnEl.addEventListener('pointerdown', (e) => {
  e.preventDefault(); e.stopPropagation(); openSessionDrawer();
}, { passive: false });
sessionBtnEl.addEventListener('touchend', (e) => {
  e.preventDefault(); e.stopPropagation();
}, { passive: false });
sessionBtnEl.addEventListener('click', (e) => {
  e.stopPropagation(); openSessionDrawer();
});
// Scrim closes drawer
document.getElementById('session-scrim').addEventListener('click', closeSessionDrawer);
// New session from drawer
document.getElementById('sd-new-session').addEventListener('click', () => {
  const s = createSession();
  switchSession(s.id);
  closeSessionDrawer();
  toast(s.name);
  // Immediately open drawer for rename
  setTimeout(() => { openSessionDrawer(); }, 300);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Drawer utilities (merged from tray)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('sd-export').addEventListener('click', () => {
  // Show export options
  const menu = document.createElement('div');
  menu.style.cssText = `
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    background:rgba(10,10,15,0.98);border:1px solid rgba(255,255,255,0.15);
    border-radius:16px;padding:16px;z-index:200;
    backdrop-filter:blur(20px);min-width:280px;
  `;
  menu.innerHTML = `
    <div style="font-size:14px;color:rgba(255,255,255,0.8);margin-bottom:12px;font-weight:500">Export Options</div>
    <button id="export-json" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">ðŸ’¾ Download JSON</button>
    <button id="export-copy" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">ðŸ“‹ Copy to Clipboard</button>
    <button id="export-qr" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:12px;font-family:inherit">ðŸ“± Show QR Code</button>
    <button id="export-cancel" style="width:100%;padding:10px;background:transparent;border:none;color:rgba(255,255,255,0.4);font-size:13px;cursor:pointer;font-family:inherit">Cancel</button>
  `;
  document.body.appendChild(menu);
  
  const data = JSON.stringify({
    thoughts:state.thoughts, connections:state.connections, folders:state.folders,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  }, null, 2);
  
  // Download JSON
  menu.querySelector('#export-json').addEventListener('click', () => {
    const blob = new Blob([data],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download=`atem-${new Date().toISOString().slice(0,10)}.json`;
    a.click(); URL.revokeObjectURL(url);
    menu.remove();
    closeSessionDrawer(); toast('downloaded');
  });
  
  // Copy to clipboard
  menu.querySelector('#export-copy').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(data);
      menu.remove();
      closeSessionDrawer(); toast('copied to clipboard');
    } catch(e) {
      toast('copy failed');
    }
  });
  
  // Show QR code
  menu.querySelector('#export-qr').addEventListener('click', () => {
    menu.remove();
    const qrContainer = document.createElement('div');
    qrContainer.style.cssText = `
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      background:rgba(10,10,15,0.98);border:1px solid rgba(255,255,255,0.15);
      border-radius:16px;padding:20px;z-index:200;
      backdrop-filter:blur(20px);text-align:center;
    `;
    
    // Compress data for QR
    const compressed = JSON.stringify({
      t:state.thoughts, c:state.connections, f:state.folders,
      s: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
    });
    
    qrContainer.innerHTML = `
      <div style="font-size:14px;color:rgba(255,255,255,0.8);margin-bottom:16px">Scan to import</div>
      <div id="qr-canvas" style="background:white;padding:16px;border-radius:12px;display:inline-block"></div>
      <div style="font-size:11px;color:rgba(255,255,255,0.3);margin-top:12px">${state.thoughts.length} thoughts, ${state.connections.length} connections</div>
      <button id="qr-close" style="margin-top:16px;width:100%;padding:10px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.7);font-size:13px;cursor:pointer;font-family:inherit">Close</button>
    `;
    document.body.appendChild(qrContainer);
    
    // Generate QR using a simple canvas-based approach
    const qrDiv = qrContainer.querySelector('#qr-canvas');
    qrDiv.innerHTML = `<div style="padding:40px;font-size:12px;color:#333">QR: ${compressed.length} chars<br><small>Too large for QR - use Copy instead</small></div>`;
    
    qrContainer.querySelector('#qr-close').addEventListener('click', () => {
      qrContainer.remove();
      closeSessionDrawer();
    });
  });
  
  // Cancel
  menu.querySelector('#export-cancel').addEventListener('click', () => {
    menu.remove();
  });
});

document.getElementById('sd-import').addEventListener('click', () => {
  // Show import options
  const menu = document.createElement('div');
  menu.style.cssText = `
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    background:rgba(10,10,15,0.98);border:1px solid rgba(255,255,255,0.15);
    border-radius:16px;padding:16px;z-index:200;
    backdrop-filter:blur(20px);min-width:280px;
  `;
  menu.innerHTML = `
    <div style="font-size:14px;color:rgba(255,255,255,0.8);margin-bottom:12px;font-weight:500">Import Options</div>
    <button id="import-file" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">ðŸ“‚ Choose JSON File</button>
    <button id="import-paste" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:12px;font-family:inherit">ðŸ“‹ Paste from Clipboard</button>
    <button id="import-cancel" style="width:100%;padding:10px;background:transparent;border:none;color:rgba(255,255,255,0.4);font-size:13px;cursor:pointer;font-family:inherit">Cancel</button>
  `;
  document.body.appendChild(menu);
  
  // File import
  menu.querySelector('#import-file').addEventListener('click', () => {
    menu.remove();
    const input = document.createElement('input');
    input.type='file'; input.accept='.json';
    input.onchange = (ev) => {
      const file = ev.target.files[0]; if(!file) return;
      const reader = new FileReader();
      reader.onload = (r) => {
        try {
          const data = JSON.parse(r.target.result);
          importData(data);
        } catch(err){toast('import failed');}
      };
      reader.readAsText(file);
    };
    input.click();
    closeSessionDrawer();
  });
  
  // Paste import
  menu.querySelector('#import-paste').addEventListener('click', async () => {
    menu.remove();
    try {
      const text = await navigator.clipboard.readText();
      const data = JSON.parse(text);
      importData(data);
      closeSessionDrawer();
    } catch(e) {
      toast('paste failed - check clipboard');
    }
  });
  
  // Cancel
  menu.querySelector('#import-cancel').addEventListener('click', () => {
    menu.remove();
  });
  
  function importData(data) {
    if (data.thoughts || data.t) {
      while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
      while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
      
      // Support both full and compressed format
      state.thoughts = data.thoughts || data.t || [];
      state.connections = data.connections || data.c || [];
      state.folders = data.folders || data.f || [];
      state.sessions = (data.sessions || data.s || []).map(s => ({ 
        ...s, 
        thoughtIds: new Set(s.thoughtIds||[]) 
      }));
      
      // Migrate: ensure new fields have defaults
      for(const t of state.thoughts){ if(!t.size) t.size=1.0; }
      for(const c of state.connections){ if(!c.color) c.color='#6ea8fe'; }
      
      for(const t of state.thoughts) addThoughtMesh(t);
      rebuildMaps();
      rebuildConnections(); applyFilter(); save();
      toast('imported '+state.thoughts.length+' thoughts');
      if(state.thoughts.length>0) hideHint();
    }
  }
});

function updateDrawerCaptureToggle() {
  const dot = document.getElementById('sd-capture-dot');
  if (dot) dot.classList.toggle('on', !!state.openToCapture);
}

document.getElementById('sd-open-capture').addEventListener('click', () => {
  state.openToCapture=!state.openToCapture; updateDrawerCaptureToggle(); updateCaptureToggle(); save();
  toast(state.openToCapture?'will open to capture':'will open to board');
  closeSessionDrawer();
});

document.getElementById('sd-migrate').addEventListener('click', () => {
  if (!confirm('move all thoughts to Session 1?')) return;
  
  // Find or create Session 1
  let s1 = state.sessions.find(s => s.name === 'Session 1');
  if (!s1) {
    s1 = createSession('Session 1', []);
  }
  
  // Add all thoughts to Session 1
  state.thoughts.forEach(t => s1.thoughtIds.add(t.id));
  
  // Recolor all to Session 1 color
  const color = s1.hue !== undefined ? `hsl(${s1.hue}, 70%, 60%)` : COLORS[0];
  state.thoughts.forEach(t => {
    t.color = color;
    const mesh = getMesh(t.id);
    if (mesh) {
      mesh.material.color.set(color);
      mesh.material.emissive.set(color);
    }
  });
  
  save();
  renderSessionList();
  toast(`${state.thoughts.length} thoughts â†’ Session 1`);
  closeSessionDrawer();
});

document.getElementById('sd-clear').addEventListener('click', () => {
  if(!confirm('clear all thoughts?')) return;
  state.thoughts=[]; state.connections=[]; state.folders=[]; state.activeFolder=null;
  state.sessions=[]; state.activeSession=null;
  while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
  while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  renderFolderBar(); applyFilter(); save();
  closeSessionDrawer(); toast('cleared');
});

document.getElementById('sd-reset-view').addEventListener('click', () => { camera.position.set(0,0,18); controls.target.set(0,0,0); save(); closeSessionDrawer(); });
document.getElementById('sd-dump-state').addEventListener('click', () => {
  const dump = { ...state, sessions: state.sessions.map(s=>({...s,thoughtIds:Array.from(s.thoughtIds)})) };
  console.log(JSON.stringify(dump, null, 2));
  closeSessionDrawer(); toast('state â†’ console');
});
document.getElementById('sd-force-save').addEventListener('click', () => { save(); closeSessionDrawer(); toast('saved'); });
document.getElementById('sd-test-thought').addEventListener('click', () => {
  const x = (Math.random() - 0.5) * 10;
  const y = (Math.random() - 0.5) * 10;
  const z = (Math.random() - 0.5) * 5;
  const text = `test ${Date.now().toString(36)}`;
  createThought(x, y, z, text);
  closeSessionDrawer();
  toast('test thought added');
});

document.getElementById('sd-bulk-test').addEventListener('click', () => {
  closeSessionDrawer();
  
  // Show menu
  const menu = document.createElement('div');
  menu.style.cssText = `
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    background:rgba(10,10,15,0.98);border:1px solid rgba(255,255,255,0.15);
    border-radius:16px;padding:16px;z-index:200;
    backdrop-filter:blur(20px);min-width:280px;
  `;
  menu.innerHTML = `
    <div style="font-size:14px;color:rgba(255,255,255,0.8);margin-bottom:12px;font-weight:500">Generate Test Thoughts</div>
    <button id="gen-100" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">100 thoughts</button>
    <button id="gen-500" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:8px;font-family:inherit">500 thoughts</button>
    <button id="gen-1000" style="width:100%;padding:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:rgba(255,255,255,0.8);font-size:13px;cursor:pointer;margin-bottom:12px;font-family:inherit">1000 thoughts</button>
    <button id="gen-cancel" style="width:100%;padding:10px;background:transparent;border:none;color:rgba(255,255,255,0.4);font-size:13px;cursor:pointer;font-family:inherit">Cancel</button>
  `;
  document.body.appendChild(menu);
  
  function generateBulk(count) {
    const start = performance.now();
    const spread = Math.sqrt(count) * 2; // Scale spread with count
    
    for(let i = 0; i < count; i++) {
      const x = (Math.random() - 0.5) * spread;
      const y = (Math.random() - 0.5) * spread;
      const z = (Math.random() - 0.5) * spread * 0.5;
      const text = `test-${i}-${Date.now().toString(36)}`;
      createThought(x, y, z, text);
    }
    
    const elapsed = performance.now() - start;
    menu.remove();
    toast(`generated ${count} thoughts in ${Math.round(elapsed)}ms`);
  }
  
  menu.querySelector('#gen-100').addEventListener('click', () => generateBulk(100));
  menu.querySelector('#gen-500').addEventListener('click', () => generateBulk(500));
  menu.querySelector('#gen-1000').addEventListener('click', () => generateBulk(1000));
  menu.querySelector('#gen-cancel').addEventListener('click', () => menu.remove());
});

document.getElementById('sd-clean-connections').addEventListener('click', () => {
  const before = state.connections.length;
  // Clean orphaned connections
  state.connections = state.connections.filter(c => {
    const fromExists = state.thoughts.find(t => t.id === c.from);
    const toExists = state.thoughts.find(t => t.id === c.to);
    return fromExists && toExists;
  });
  const removed = before - state.connections.length;
  rebuildConnections();
  save();
  closeSessionDrawer();
  toast(`cleaned ${removed} orphaned connection${removed !== 1 ? 's' : ''}`);
});

document.getElementById('sd-show-orphans').addEventListener('click', () => {
  const connected = new Set();
  for(const c of state.connections){connected.add(c.from);connected.add(c.to);}
  let count=0;
  for(const mesh of thoughtGroup.children){
    if(!connected.has(mesh.userData.id)){
      count++;
      mesh.material.emissive.set('#ff4444'); mesh.material.emissiveIntensity=0.8;
      setTimeout(()=>{
        const t=state.thoughts.find(x=>x.id===mesh.userData.id);
        if(t) mesh.material.emissive.set(t.color||'#6ea8fe');
        mesh.userData.targetEmissive=0.15;
      },1500);
    }
  }
  closeSessionDrawer(); toast(count+' orphan'+(count!==1?'s':''));
});
document.getElementById('sd-toggle-fps').addEventListener('click', () => {
  showFps=!showFps;
  document.getElementById('fps').classList.toggle('on', showFps);
  document.getElementById('sd-fps-dot').classList.toggle('on', showFps);
  closeSessionDrawer();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Persistence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function save() {
  state.camera = {
    px:camera.position.x,py:camera.position.y,pz:camera.position.z,
    tx:controls.target.x,ty:controls.target.y,tz:controls.target.z
  };
  // Serialize sessions (Set â†’ Array)
  const serializable = {
    ...state,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  };
  
  // Primary: IndexedDB
  try {
    await set('atem-state', serializable);
  } catch(e) {
    console.warn('IndexedDB save failed', e);
  }
  
  // Fallback: localStorage (for export compatibility)
  try { 
    localStorage.setItem('atem-state-backup', JSON.stringify(serializable)); 
  } catch(e){}
}

async function load() {
  let s = null;
  
  // Try IndexedDB first
  try {
    s = await get('atem-state');
  } catch(e) {
    console.warn('IndexedDB load failed', e);
  }
  
  // Fallback to localStorage if IndexedDB empty
  if (!s) {
    try {
      const raw = localStorage.getItem('atem-state') || localStorage.getItem('atem-state-backup');
      if (raw) {
        s = JSON.parse(raw);
        // Migrate to IndexedDB
        if (s) {
          await set('atem-state', s);
          console.log('Migrated from localStorage to IndexedDB');
        }
      }
    } catch(e) {
      console.warn('localStorage load failed', e);
    }
  }
  
  if (!s) {
    // No data - show import hint
    setTimeout(() => {
      if (state.thoughts.length === 0) {
        toast('no data found - import your thoughts or start fresh', 5000);
      }
    }, 1000);
    return;
  }
  
  // Hydrate state
  try {
    state.version = s.version || state.version;
    state.thoughts = s.thoughts||[]; 
    state.connections = s.connections||[];
    state.folders = s.folders||[]; 
    state.activeFolder = s.activeFolder||null;
    state.openToCapture = s.openToCapture||false;
    
    // v5 migration
    state.sessions = (s.sessions||[]).map(sess => ({
      ...sess,
      thoughtIds: new Set(sess.thoughtIds || [])
    }));
    state.activeSession = s.activeSession || null;
    
    // Validate activeSession still exists
    if (state.activeSession && !getSession(state.activeSession)) {
      // Fall back to most recently touched
      if (state.sessions.length > 0) {
        const sorted = [...state.sessions].sort((a,b) => b.touched - a.touched);
        state.activeSession = sorted[0].id;
      } else {
        state.activeSession = null;
      }
    }
    
    if (s.camera) { 
      camera.position.set(s.camera.px,s.camera.py,s.camera.pz); 
      controls.target.set(s.camera.tx,s.camera.ty,s.camera.tz); 
    }
    
    for (const t of state.thoughts) { if (t.folder===undefined) t.folder=null; }
    
    // Clean orphaned connections
    const validIds = new Set(state.thoughts.map(t => t.id));
    state.connections = state.connections.filter(c => validIds.has(c.from) && validIds.has(c.to));
    
    // Auto-migrate: move all orphaned thoughts to "Session 1"
    if (state.thoughts.length > 0 && state.sessions.length === 0) {
      const allIds = state.thoughts.map(t => t.id);
      const s1 = createSession('Session 1', allIds);
      state.activeSession = s1.id;
      toast('all thoughts moved to Session 1');
    }
    
    for (const t of state.thoughts) addThoughtMesh(t);
    rebuildMaps();
    rebuildConnections(); applyFilter(); updateCaptureToggle();
    if (state.thoughts.length > 0) hideHint();
  } catch(e) { 
    console.warn('state hydration failed', e); 
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function uid() { return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }

function createThought(x, y, z, text, color) {
  // Default color: if in session, use session's hue; otherwise cycle through palette
  let defaultColor;
  if (!color && state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      // Convert session hue to color
      defaultColor = `hsl(${sess.hue}, 70%, 60%)`;
    }
  }
  if (!defaultColor) defaultColor = COLORS[colorIdx++ % COLORS.length];
  
  const t = {
    id:uid(), text:text||'',
    position:[x,y,z],
    color: color || defaultColor,
    created:Date.now(), touched:Date.now(),
    size: 1.0
  };
  state.thoughts.push(t);
  thoughtMap.set(t.id, t);
  // Auto-add to active session
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess) { sess.thoughtIds.add(t.id); sess.touched = Date.now(); }
  }
  addThoughtMesh(t); applyFilter(); save(); hideHint();
  return t;
}

function updateThought(id, text, folder, color, size) {
  const t = state.thoughts.find(t => t.id===id);
  if (!t) return;
  t.text = text; t.touched = Date.now();
  if (folder !== undefined) t.folder = folder;
  if (color !== undefined) t.color = color;
  if (size !== undefined) t.size = size;
  const mesh = getMesh(id);
  if (mesh) {
    updateLabel(mesh, text);
    if (color) { mesh.material.color.set(color); mesh.material.emissive.set(color); }
    if (size !== undefined) mesh.scale.setScalar(size);
  }
  thoughtMap.set(id, t);
  applyFilter(); save();
}

function deleteThought(id) {
  state.thoughts = state.thoughts.filter(t=>t.id!==id);
  state.connections = state.connections.filter(c=>c.from!==id&&c.to!==id);
  for (const s of state.sessions) s.thoughtIds.delete(id);
  const mesh = getMesh(id);
  if (mesh) thoughtGroup.remove(mesh);
  thoughtMap.delete(id);
  meshMap.delete(id);
  rebuildConnections(); save();
}

function moveThought(id, x, y, z) {
  const t = thoughtMap.get(id) || state.thoughts.find(t=>t.id===id);
  if (t) { t.position=[x,y,z]; t.touched=Date.now(); }
}

function addConnection(fromId, toId, label, color) {
  if (fromId===toId) return;
  const conn = { id:uid(), from:fromId, to:toId, created:Date.now(), label: label||null, color: color||'#6ea8fe' };
  state.connections.push(conn);
  rebuildConnections(); applyFilter(); save();
  needsRender = true;
  // Open connection editor for the new connection
  if (!label) openConnEditor(conn.id);
  else toast('connected');
}

function deleteConnection(connKey) {
  state.connections = state.connections.filter(c => [c.from,c.to].sort().join('|') !== connKey);
  rebuildConnections(); applyFilter(); save(); toast('disconnected');
  needsRender = true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Connection Editor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let editingConnId = null;
const connEditorEl = document.getElementById('conn-editor');
const connCustomInput = document.getElementById('conn-custom-input');

function openConnEditor(connId) {
  const conn = state.connections.find(c => c.id === connId);
  if (!conn) return;
  editingConnId = connId;
  controls.enabled = false;
  
  // Render presets
  const presetRow = document.getElementById('conn-preset-row');
  presetRow.innerHTML = CONN_PRESETS.map(p => 
    `<button class="conn-preset${conn.label===p.label?' active':''}" data-label="${p.label}" data-color="${p.color}">${p.label}</button>`
  ).join('');
  
  // Preset click handlers  
  presetRow.querySelectorAll('.conn-preset').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      presetRow.querySelectorAll('.conn-preset').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      connCustomInput.value = '';
      conn.label = btn.dataset.label;
      conn.color = btn.dataset.color;
      // Update color swatch selection
      document.querySelectorAll('#conn-color-row .conn-cswatch').forEach(s => {
        s.classList.toggle('active', s.dataset.color === conn.color);
      });
      rebuildConnections(); applyFilter(); save();
    });
  });
  
  // Custom input
  connCustomInput.value = (conn.label && !CONN_PRESETS.find(p=>p.label===conn.label)) ? conn.label : '';
  connCustomInput.oninput = () => {
    const v = connCustomInput.value.trim();
    if (v) {
      presetRow.querySelectorAll('.conn-preset').forEach(b => b.classList.remove('active'));
      conn.label = v;
      rebuildConnections(); save();
    }
  };
  
  // Color swatches
  const colorRow = document.getElementById('conn-color-row');
  colorRow.innerHTML = CONN_COLORS.map(c =>
    `<div class="conn-cswatch${conn.color===c?' active':''}" data-color="${c}" style="background:${c}"></div>`
  ).join('');
  colorRow.querySelectorAll('.conn-cswatch').forEach(swatch => {
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      colorRow.querySelectorAll('.conn-cswatch').forEach(s => s.classList.remove('active'));
      swatch.classList.add('active');
      conn.color = swatch.dataset.color;
      rebuildConnections(); save();
    });
  });
  
  connEditorEl.classList.add('open');
}

function closeConnEditor() {
  editingConnId = null;
  connEditorEl.classList.remove('open');
  controls.enabled = true;
  needsRender = true;
}

document.getElementById('conn-done-btn').addEventListener('click', () => closeConnEditor());
document.getElementById('conn-del-btn').addEventListener('click', () => {
  if (editingConnId) {
    const conn = state.connections.find(c => c.id === editingConnId);
    if (conn) {
      const key = [conn.from, conn.to].sort().join('|');
      deleteConnection(key);
    }
  }
  closeConnEditor();
});
connCustomInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { e.preventDefault(); closeConnEditor(); }
  if (e.key === 'Escape') { e.preventDefault(); closeConnEditor(); }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Editor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const editorEl = document.getElementById('editor');
const edText = document.getElementById('ed-text');

function renderEditorColors() {
  const btn = document.getElementById('ed-color-btn');
  const palette = document.getElementById('ed-color-palette');
  if (!btn || !palette) return;
  
  // Set button color to current editing color
  btn.style.background = editingColor;
  
  // Generate palette based on session
  let colors = COLORS;
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      colors = [
        `hsl(${sess.hue}, 70%, 60%)`,
        `hsl(${sess.hue}, 80%, 65%)`,
        `hsl(${sess.hue}, 60%, 55%)`,
        `hsl(${(sess.hue + 30) % 360}, 70%, 60%)`,
        `hsl(${(sess.hue - 30 + 360) % 360}, 70%, 60%)`,
        `hsl(${sess.hue}, 50%, 50%)`,
        `hsl(${sess.hue}, 90%, 70%)`,
        `hsl(${sess.hue}, 40%, 45%)`
      ];
    }
  }
  
  // Render palette
  palette.innerHTML = colors.map(c => 
    `<div class="ed-color-swatch" data-color="${c}" style="background:${c}"></div>`
  ).join('');
  
  // Toggle palette on button click
  btn.onclick = (e) => {
    e.stopPropagation();
    palette.classList.toggle('open');
  };
  
  // Select color from palette
  palette.querySelectorAll('.ed-color-swatch').forEach(swatch => {
    swatch.onclick = (e) => {
      e.stopPropagation();
      editingColor = swatch.dataset.color;
      btn.style.background = editingColor;
      palette.classList.remove('open');
      
      if (editingId) {
        const mesh = getMesh(editingId);
        if (mesh) {
          mesh.material.color.set(editingColor);
          mesh.material.emissive.set(editingColor);
        }
      }
    };
  });
  
  // Close palette when clicking outside
  document.addEventListener('click', () => palette.classList.remove('open'));
}

function renderEditorFolders() {
  // Deprecated - folders removed
}

function renderEditorSessions() {
  const row = document.getElementById('ed-session-row');
  if (!editingId) { row.innerHTML = ''; return; }
  const sessions = sessionsForThought(editingId);
  if (sessions.length === 0 && !state.activeSession) { row.innerHTML = ''; return; }
  let html = '';
  if (sessions.length > 0) {
    for (const s of sessions) html += `<span class="s-badge">${s.name}</span>`;
  }
  // Show "remove from session" if in active session
  if (state.activeSession) {
    const active = getActiveSession();
    if (active && active.thoughtIds.has(editingId)) {
      html += `<span id="ed-remove-session">remove from ${active.name}</span>`;
    }
  }
  row.innerHTML = html;
  const rmBtn = document.getElementById('ed-remove-session');
  if (rmBtn) {
    rmBtn.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      const active = getActiveSession();
      if (active) {
        active.thoughtIds.delete(editingId);
        active.touched = Date.now();
        save(); applyFilter();
        toast('removed from ' + active.name);
      }
      closeEditor(false);
    });
  }
}

function openEditor(id) {
  clearSelection(); closeConnDeletePill(); closeConnEditor();
  editingId = id;
  const t = state.thoughts.find(t=>t.id===id);
  edText.value = t ? t.text : '';
  editingFolder = t ? (t.folder||null) : (state.activeFolder||null);
  editingColor = t ? t.color : COLORS[0];
  editingSize = t ? (t.size || 1.0) : 1.0;
  renderEditorColors(); renderEditorFolders(); renderEditorSessions();
  // Size buttons
  document.querySelectorAll('.size-btn').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.dataset.size) === editingSize);
  });
  editorEl.classList.add('open'); controls.enabled=false;
  edText.style.height='auto';
  
  // Glow connections from this thought
  for (const child of lineGroup.children) {
    if (child.userData.isConnLabel) continue;
    if (child.userData.from === id || child.userData.to === id) {
      child.material.opacity = Math.min((child.userData.baseOpacity || 0.35) + 0.3, 1.0);
      // Fade back after a moment
      const base = child.userData.baseOpacity || 0.35;
      setTimeout(() => { if (child.material) child.material.opacity = base; needsRender = true; }, 800);
    }
  }
  needsRender = true;
  
  setTimeout(()=>{ edText.focus(); edText.selectionStart=edText.value.length; }, 50);
}

function closeEditor(doSave) {
  if (doSave && editingId) {
    const text = edText.value.trim();
    if (!text) deleteThought(editingId);
    else updateThought(editingId, text, editingFolder, editingColor, editingSize);
  }
  editingId=null; editingFolder=null; editingColor=null; editingSize=1.0;
  editorEl.classList.remove('open'); controls.enabled=true;
  renderFolderBar();
}

document.getElementById('save-btn').addEventListener('click',()=>closeEditor(true));
document.getElementById('cancel-btn').addEventListener('click',()=>{
  if (editingId) { const t=state.thoughts.find(t=>t.id===editingId); if(t&&!t.text) deleteThought(editingId); }
  closeEditor(false);
});
document.getElementById('del-btn').addEventListener('click',()=>{ if(editingId) deleteThought(editingId); closeEditor(false); });
edText.addEventListener('keydown',(e)=>{
  if(e.key==='Escape'){closeEditor(false);e.preventDefault();}
  if(e.key==='Enter'&&!e.shiftKey){closeEditor(true);e.preventDefault();}
});
edText.addEventListener('input',()=>{ edText.style.height='auto'; edText.style.height=Math.min(edText.scrollHeight,200)+'px'; });

// Size buttons
document.querySelectorAll('.size-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    editingSize = parseFloat(btn.dataset.size);
    document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    // Live preview
    if (editingId) {
      const mesh = getMesh(editingId);
      if (mesh) mesh.scale.setScalar(editingSize);
      needsRender = true;
    }
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Connection delete pill
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const connPill = document.getElementById('conn-delete-pill');
function showConnDeletePill(x, y, connKey) { pendingDeleteConnId=connKey; connPill.style.left=x+'px'; connPill.style.top=y+'px'; connPill.classList.add('open'); }
function closeConnDeletePill() { pendingDeleteConnId=null; connPill.classList.remove('open'); }
connPill.addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); if(pendingDeleteConnId) deleteConnection(pendingDeleteConnId); closeConnDeletePill(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Lasso select
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const lassoRect = document.getElementById('lasso-rect');
const lassoBar = document.getElementById('lasso-bar');

function clearSelection() {
  selectedIds.clear();
  lassoBar.classList.remove('open');
  lassoRect.style.display = 'none';
  for (const mesh of thoughtGroup.children) {
    const t = state.thoughts.find(x=>x.id===mesh.userData.id);
    if (t && isThoughtVisible(t)) mesh.userData.targetEmissive = 0.15;
  }
}

function updateLassoRect() {
  if (!lassoStart || !lassoEnd) return;
  const x = Math.min(lassoStart.x, lassoEnd.x), y = Math.min(lassoStart.y, lassoEnd.y);
  const w = Math.abs(lassoEnd.x - lassoStart.x), h = Math.abs(lassoEnd.y - lassoStart.y);
  lassoRect.style.display = 'block';
  lassoRect.style.left=x+'px'; lassoRect.style.top=y+'px';
  lassoRect.style.width=w+'px'; lassoRect.style.height=h+'px';
}

function finishLasso() {
  if (!lassoStart || !lassoEnd) { lassoRect.style.display='none'; return; }
  const x1=Math.min(lassoStart.x,lassoEnd.x), y1=Math.min(lassoStart.y,lassoEnd.y);
  const x2=Math.max(lassoStart.x,lassoEnd.x), y2=Math.max(lassoStart.y,lassoEnd.y);
  if (x2-x1 < 20 && y2-y1 < 20) { lassoRect.style.display='none'; return; }
  selectedIds.clear();
  for (const mesh of thoughtGroup.children) {
    const t = state.thoughts.find(x=>x.id===mesh.userData.id);
    if (!t || !isThoughtVisible(t)) continue;
    const sp = mesh.position.clone().project(camera);
    const sx = (sp.x+1)/2 * window.innerWidth, sy = (1-sp.y)/2 * window.innerHeight;
    if (sx>=x1 && sx<=x2 && sy>=y1 && sy<=y2) { selectedIds.add(t.id); mesh.userData.targetEmissive = 0.5; }
  }
  lassoRect.style.display = 'none';
  if (selectedIds.size > 0) { lassoBar.classList.add('open'); toast(selectedIds.size + ' selected'); }
}

document.getElementById('lasso-clear-btn').addEventListener('pointerdown',(e)=>{ e.stopPropagation(); e.preventDefault(); clearSelection(); });

// Lasso â†’ recolor selected
document.getElementById('lasso-recolor-btn').addEventListener('pointerdown',(e)=>{
  e.stopPropagation(); e.preventDefault();
  if (selectedIds.size === 0) return;
  
  // Use active session's base color, or first color in palette
  let color = COLORS[0];
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      color = `hsl(${sess.hue}, 70%, 60%)`;
    }
  }
  
  // Recolor all selected thoughts
  for (const id of selectedIds) {
    updateThought(id, state.thoughts.find(t=>t.id===id)?.text, null, color);
    const mesh = getMesh(id);
    if (mesh) {
      mesh.material.color.set(color);
      mesh.material.emissive.set(color);
    }
  }
  
  save();
  toast(`${selectedIds.size} recolored`);
  clearSelection();
});

// Lasso â†’ new session
document.getElementById('lasso-new-session-btn').addEventListener('pointerdown',(e)=>{
  e.stopPropagation(); e.preventDefault();
  if (selectedIds.size === 0) return;
  const name = prompt('session name')?.trim();
  if (!name) return;
  const s = createSession(name, selectedIds);
  switchSession(s.id);
  toast(s.name + ' (' + s.thoughtIds.size + ')');
  clearSelection();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Raycast helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ndcFromEvent(e) {
  const x = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
  const y = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
  pointer.set((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
}

function hitThought(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const visible = thoughtGroup.children.filter(m => {
    const t = state.thoughts.find(x=>x.id===m.userData.id);
    return t && isThoughtVisible(t);
  });
  const hits = raycaster.intersectObjects(visible, false);
  return hits.length ? hits[0].object : null;
}

function hitLine(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const visibleLines = lineGroup.children.filter(l => l.visible);
  const hits = raycaster.intersectObjects(visibleLines, false);
  return hits.length ? hits[0].object : null;
}

function worldPosFromScreen(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const camDir = camera.getWorldDirection(new THREE.Vector3());
  plane.setFromNormalAndCoplanarPoint(camDir.negate(), controls.target);
  raycaster.ray.intersectPlane(plane, intersectPt);
  return intersectPt.clone();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pointer interaction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function pxFromEvent(e) { return { x: e.clientX??e.touches?.[0]?.clientX??0, y: e.clientY??e.touches?.[0]?.clientY??0 }; }

function isOverlayOpen() {
  return editorEl.classList.contains('open') || connEditorEl.classList.contains('open');
}

function onPointerDown(e) {
  if (isOverlayOpen()) return;
  if (e.target !== canvas) return;
  if (e.touches && e.touches.length > 1) { clearHold(); return; }
  closeConnDeletePill();
  const px = pxFromEvent(e);
  pointerStart = px; pointerMoved = false; holdTriggered = false;
  isDragging = false; lassoActive = false; lassoHoldTriggered = false;
  const hit = hitThought(e);
  if (hit) {
    draggedMesh = hit;
    const wp = worldPosFromScreen(e);
    dragOffset.copy(draggedMesh.position).sub(wp);
    holdTimer = setTimeout(()=>{
      if (!pointerMoved) {
        holdTriggered = true;
        connectSource = draggedMesh.userData.id;
        draggedMesh.material.emissiveIntensity = 0.6;
        pendingLineMesh.visible = true;
        if (navigator.vibrate) navigator.vibrate(30);
      }
    }, HOLD_MS);
    controls.enabled = false;
  } else {
    draggedMesh = null;
    lassoStart = px;
    lassoHoldTimer = setTimeout(()=>{
      if (!pointerMoved) {
        lassoHoldTriggered = true; lassoActive = true;
        if (navigator.vibrate) navigator.vibrate(20);
      }
    }, HOLD_MS);
    controls.enabled = true;
  }
}

function onPointerMove(e) {
  if (isOverlayOpen()) return;
  if (e.touches && e.touches.length > 1) { clearHold(); clearTimeout(lassoHoldTimer); lassoActive=false; lassoRect.style.display='none'; return; }
  const px = pxFromEvent(e);
  const dx = px.x-pointerStart.x, dy = px.y-pointerStart.y;
  if (Math.sqrt(dx*dx+dy*dy) > DRAG_THRESH) pointerMoved = true;
  if (draggedMesh && !holdTriggered && pointerMoved) {
    clearTimeout(holdTimer); isDragging = true;
    const wp = worldPosFromScreen(e);
    draggedMesh.position.copy(wp.add(dragOffset));
    moveThought(draggedMesh.userData.id, draggedMesh.position.x, draggedMesh.position.y, draggedMesh.position.z);
    updateConnectionPositions();
  }
  if (holdTriggered && connectSource) {
    const srcMesh = getMesh(connectSource);
    if (srcMesh) {
      const wp = worldPosFromScreen(e);
      const pos = pendingLineMesh.geometry.attributes.position;
      pos.setXYZ(0, srcMesh.position.x, srcMesh.position.y, srcMesh.position.z);
      pos.setXYZ(1, wp.x, wp.y, wp.z);
      pos.needsUpdate = true;
    }
    const hit = hitThought(e);
    for (const child of thoughtGroup.children) {
      const t = state.thoughts.find(x=>x.id===child.userData.id);
      if (t && isThoughtVisible(t)) child.userData.targetEmissive = (hit===child && child.userData.id!==connectSource) ? 0.5 : 0.15;
    }
  }
  if (lassoActive && lassoHoldTriggered) { controls.enabled = false; lassoEnd = px; updateLassoRect(); }
}

function onPointerUp(e) {
  if (isOverlayOpen()) return;
  clearTimeout(holdTimer); clearTimeout(lassoHoldTimer);
  if (lassoActive && lassoHoldTriggered && lassoEnd) {
    finishLasso(); lassoActive=false; lassoHoldTriggered=false; lassoStart=null; lassoEnd=null;
    controls.enabled = true; return;
  }
  lassoActive=false; lassoHoldTriggered=false; lassoStart=null; lassoEnd=null; lassoRect.style.display='none';
  if (holdTriggered && connectSource) {
    pendingLineMesh.visible = false;
    const hit = hitThought(e);
    if (hit && hit.userData.id !== connectSource) addConnection(connectSource, hit.userData.id);
    const src = getMesh(connectSource);
    if (src) src.userData.targetEmissive = 0.15;
    for (const child of thoughtGroup.children) child.userData.targetEmissive = 0.15;
    connectSource = null; applyFilter();
  } else if (isDragging && draggedMesh) {
    save();
  } else if (draggedMesh && !pointerMoved) {
    openEditor(draggedMesh.userData.id);
  } else if (!draggedMesh && !pointerMoved) {
    if (selectedIds.size > 0) { clearSelection(); }
    else {
      const lineHit = hitLine(e);
      if (lineHit && lineHit.userData.connKey) {
        // Find the connection and open editor
        const connKey = lineHit.userData.connKey;
        const conn = state.connections.find(c => [c.from,c.to].sort().join('|') === connKey);
        if (conn) {
          openConnEditor(conn.id);
        }
      } else {
        const wp = worldPosFromScreen(e);
        const t = createThought(wp.x, wp.y, wp.z);
        openEditor(t.id);
      }
    }
  }
  draggedMesh = null; isDragging = false; holdTriggered = false; controls.enabled = true;
}

function clearHold() {
  clearTimeout(holdTimer); holdTriggered = false;
  if (connectSource) { const src = getMesh(connectSource); if (src) src.userData.targetEmissive = 0.15; connectSource = null; pendingLineMesh.visible = false; }
}

canvas.addEventListener('touchstart', onPointerDown, { passive:false });
canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); onPointerMove(e); }, { passive:false });
canvas.addEventListener('touchend', onPointerUp);
canvas.addEventListener('touchcancel', ()=>{ clearHold(); clearTimeout(lassoHoldTimer); lassoActive=false; lassoRect.style.display='none'; draggedMesh=null; isDragging=false; controls.enabled=true; });
canvas.addEventListener('mousedown', onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tray
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const trayEl = document.getElementById('tray');
const trayBtn = document.getElementById('tray-btn');
const trayScrim = document.getElementById('tray-scrim');

function openTray() { trayEl.classList.add('open'); trayScrim.classList.add('open'); }
function closeTray() { trayEl.classList.remove('open'); trayScrim.classList.remove('open'); }

trayBtn.addEventListener('click', openTray);
trayScrim.addEventListener('click', closeTray);

document.getElementById('btn-export').addEventListener('click', () => {
  // v5: include sessions in export
  const data = JSON.stringify({
    thoughts:state.thoughts, connections:state.connections, folders:state.folders,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  }, null, 2);
  const blob = new Blob([data],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=`atem-${new Date().toISOString().slice(0,10)}.json`;
  a.click(); URL.revokeObjectURL(url);
  closeTray(); toast('exported');
});

document.getElementById('btn-import').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type='file'; input.accept='.json';
  input.onchange = (ev) => {
    const file = ev.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (r) => {
      try {
        const data = JSON.parse(r.target.result);
        if (data.thoughts) {
          while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
          while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
          state.thoughts=data.thoughts; state.connections=data.connections||[];
          state.folders=data.folders||[];
          // v5: import sessions
          state.sessions = (data.sessions||[]).map(s => ({ ...s, thoughtIds: new Set(s.thoughtIds||[]) }));
          for(const t of state.thoughts){if(t.folder===undefined)t.folder=null;}
          for(const t of state.thoughts) addThoughtMesh(t);
          rebuildConnections(); applyFilter(); save();
          toast('imported '+state.thoughts.length+' thoughts');
          if(state.thoughts.length>0) hideHint();
        }
      } catch(err){toast('import failed');}
    };
    reader.readAsText(file);
  };
  input.click(); closeTray();
});

function updateCaptureToggle() {
  const dot = document.getElementById('capture-toggle-dot');
  if (dot) dot.classList.toggle('on', !!state.openToCapture);
}
document.getElementById('btn-open-capture').addEventListener('click', () => {
  state.openToCapture=!state.openToCapture; updateCaptureToggle(); save();
  toast(state.openToCapture?'will open to capture':'will open to board');
  closeTray();
});

document.getElementById('btn-clear').addEventListener('click', () => {
  if(!confirm('clear all thoughts?')) return;
  state.thoughts=[]; state.connections=[]; state.folders=[]; state.activeFolder=null;
  state.sessions=[]; state.activeSession=null;
  while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
  while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  renderFolderBar(); applyFilter(); save();
  closeTray(); toast('cleared');
});

document.getElementById('btn-reset-view').addEventListener('click', () => { camera.position.set(0,0,18); controls.target.set(0,0,0); save(); closeTray(); });
document.getElementById('btn-dump-state').addEventListener('click', () => {
  // Pretty print with Sets converted
  const dump = { ...state, sessions: state.sessions.map(s=>({...s,thoughtIds:Array.from(s.thoughtIds)})) };
  console.log(JSON.stringify(dump, null, 2));
  closeTray(); toast('state â†’ console');
});
document.getElementById('btn-force-save').addEventListener('click', () => { save(); closeTray(); toast('saved'); });
document.getElementById('btn-show-orphans').addEventListener('click', () => {
  const connected = new Set();
  for(const c of state.connections){connected.add(c.from);connected.add(c.to);}
  let count=0;
  for(const mesh of thoughtGroup.children){
    if(!connected.has(mesh.userData.id)){
      count++;
      mesh.material.emissive.set('#ff4444'); mesh.material.emissiveIntensity=0.8;
      setTimeout(()=>{
        const t=state.thoughts.find(x=>x.id===mesh.userData.id);
        if(t) mesh.material.emissive.set(t.color||'#6ea8fe');
        mesh.userData.targetEmissive=0.15;
      },1500);
    }
  }
  closeTray(); toast(count+' orphan'+(count!==1?'s':''));
});
document.getElementById('btn-toggle-fps').addEventListener('click', () => {
  showFps=!showFps;
  document.getElementById('fps').classList.toggle('on', showFps);
  document.getElementById('fps-dot').classList.toggle('on', showFps);
  closeTray();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Toast & Hint
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toast(msg) { const el=document.getElementById('toast'); el.textContent=msg; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),1800); }
function hideHint() { if(!hintVisible) return; hintVisible=false; const h=document.getElementById('hint'); h.style.opacity='0'; setTimeout(()=>h.style.display='none',800); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Stats & FPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let fpsFrames=0, fpsLast=performance.now(), fpsValue=0;

function updateStats() {
  const el=document.getElementById('stats');
  const tc=state.thoughts.length, cc=state.connections.length;
  if(tc===0){el.textContent='';return;}
  let s=`${tc} thought${tc!==1?'s':''}`;
  if(cc>0) s+=` Â· ${cc} connection${cc!==1?'s':''}`;
  if(state.activeFolder) s+=` Â· ${state.activeFolder}`;
  // v5: show session-scoped count
  if(state.activeSession) {
    const sess = getActiveSession();
    if (sess) s = `${sess.thoughtIds.size} in session Â· ${tc} total`;
  }
  el.textContent=s;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Animation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = performance.now();

let needsRender = true;
function requestRender() { needsRender = true; }

// Frustum for culling
const frustum = new THREE.Frustum();
const cameraViewProjectionMatrix = new THREE.Matrix4();

function animate() {
  requestAnimationFrame(animate);
  const now=performance.now(); const dt=(now-lastTime)/1000; lastTime=now;
  fpsFrames++;
  if(now-fpsLast>=500){ fpsValue=Math.round(fpsFrames/((now-fpsLast)/1000)); fpsFrames=0; fpsLast=now; if(showFps) document.getElementById('fps').textContent=fpsValue+' fps'; }
  
  controls.update();
  
  // Update frustum for label culling
  camera.updateMatrixWorld();
  cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
  frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
  
  // Animate thoughts (breathing, emissive) + frustum cull labels
  let hasAnimation = false;
  for(const mesh of thoughtGroup.children){
    const ud=mesh.userData; ud.breath+=dt*0.8;
    if(!isDragging||mesh!==draggedMesh){ mesh.position.y+=Math.sin(ud.breath)*0.0003; mesh.position.x+=Math.cos(ud.breath*0.7)*0.0002; }
    const ce=mesh.material.emissiveIntensity; const te=ud.targetEmissive+Math.sin(ud.breath)*0.03; 
    mesh.material.emissiveIntensity+=(te-ce)*0.1;
    const co=mesh.material.opacity; mesh.material.opacity+=(ud.targetOpacity-co)*0.08;
    
    // Frustum culling for labels (hide if off-screen)
    const label = mesh.getObjectByName('label');
    if (label) {
      const inView = frustum.containsPoint(mesh.position);
      label.visible = inView && ud.targetOpacity > 0.5;
    }
    
    // Check if animation is still converging
    if(Math.abs(ce-te) > 0.01 || Math.abs(co-ud.targetOpacity) > 0.01) hasAnimation = true;
  }
  
  if(lineGroup.children.length>0) updateConnectionPositions();
  updateStats();
  
  // Only render if needed: dragging, animating, camera moving, or explicit request
  if(needsRender || isDragging || hasAnimation || controls.autoRotate) {
    renderer.render(scene, camera);
    needsRender = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Resize
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Init
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(async () => {
  await load();
  animate();
  
  // ALWAYS open to "all thoughts" view
  state.activeSession = null;
  applyFilter();
})();

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // ESC closes drawer/editor/conn-editor
  if (e.key === 'Escape') {
    const drawer = document.getElementById('session-drawer');
    const editor = document.getElementById('editor');
    if (connEditorEl.classList.contains('open')) {
      closeConnEditor();
      e.preventDefault();
    } else if (drawer.classList.contains('open')) {
      closeSessionDrawer();
      e.preventDefault();
    } else if (editor.classList.contains('open')) {
      closeEditor(false);
      e.preventDefault();
    }
  }
});

// Hover near top to show tag bar
let tagBarTimeout;
document.addEventListener('mousemove', (e) => {
  const tagBar = document.getElementById('tag-bar');
  if (e.clientY < 60) {
    tagBar.classList.add('show');
    clearTimeout(tagBarTimeout);
    tagBarTimeout = setTimeout(() => tagBar.classList.remove('show'), 2000);
  }
});

// Drag-drop import
document.body.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
});

document.body.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  const file = e.dataTransfer.files[0];
  if (file && file.name.endsWith('.json')) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.thoughts) {
          while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
          while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
          state.thoughts = data.thoughts || [];
          state.connections = data.connections || [];
          state.folders = data.folders || [];
          state.sessions = (data.sessions || []).map(s => ({
            ...s,
            thoughtIds: new Set(s.thoughtIds || [])
          }));
          for(const t of state.thoughts){ if(!t.size) t.size=1.0; }
          for(const c of state.connections){ if(!c.color) c.color='#6ea8fe'; }
          for (const t of state.thoughts) addThoughtMesh(t);
          rebuildMaps();
          rebuildConnections();
          applyFilter();
          save();
          toast(`imported ${state.thoughts.length} thoughts`);
          if (state.thoughts.length > 0) hideHint();
        }
      } catch (err) {
        toast('import failed');
      }
    };
    reader.readAsText(file);
  }
});

setInterval(save,10000);
if('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').catch(()=>{});
console.log('atem v14.0 â€” Layer 1: Expression (connections + sizes + presets)');
</script>
</body>
</html>
