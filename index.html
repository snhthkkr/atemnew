<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="atem">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#000000">
<title>atem</title>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;color:#fff}
#c{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}

/* â”€â”€â”€ Editor overlay â”€â”€â”€ */
#editor{
  position:fixed;display:none;z-index:100;
  left:50%;top:50%;transform:translate(-50%,-50%);
  width:min(340px,88vw);
  background:rgba(10,10,15,0.95);
  border:1px solid rgba(255,255,255,0.12);
  border-radius:16px;padding:16px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
}
#editor.open{display:block}
#editor textarea{
  width:100%;min-height:80px;max-height:200px;
  background:transparent;border:none;outline:none;
  color:#fff;font-size:16px;line-height:1.5;
  font-family:inherit;resize:none;
  -webkit-user-select:text;user-select:text;
}
#editor textarea::placeholder{color:rgba(255,255,255,0.25)}
#ed-color-btn{
  width:20px;height:20px;border-radius:50%;
  border:1.5px solid rgba(255,255,255,0.2);
  cursor:pointer;position:absolute;top:16px;right:16px;
  transition:transform 0.15s;z-index:5;
}
#ed-color-btn:active{transform:scale(0.9)}
#ed-color-palette{
  position:absolute;top:42px;right:16px;
  background:rgba(15,15,20,0.98);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:8px;display:none;gap:6px;
  backdrop-filter:blur(20px);z-index:10;
}
#ed-color-palette.open{display:flex}
.ed-color-swatch{
  width:28px;height:28px;border-radius:50%;cursor:pointer;
  border:2px solid rgba(255,255,255,0.15);transition:transform 0.1s;
}
.ed-color-swatch:active{transform:scale(0.85)}
#ed-folder-row{display:none !important}
.folder-chip{
  padding:4px 10px;border-radius:20px;font-size:12px;
  background:rgba(255,255,255,0.06);color:rgba(255,255,255,0.5);
  border:1px solid rgba(255,255,255,0.08);cursor:pointer;white-space:nowrap;
}
.folder-chip.active{background:rgba(110,168,254,0.2);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.3)}
.folder-chip.add-new{color:rgba(255,255,255,0.3);border-style:dashed}
#ed-folder-input{
  background:transparent;border:none;border-bottom:1px solid rgba(255,255,255,0.2);
  color:#fff;font-size:12px;padding:4px 2px;outline:none;width:80px;
  font-family:inherit;display:none;-webkit-user-select:text;user-select:text;
}
/* session row in editor */
#ed-session-row{
  display:flex;align-items:center;gap:6px;margin-top:6px;padding-top:6px;
  border-top:1px solid rgba(255,255,255,0.04);flex-wrap:wrap;
}
#ed-session-row .s-badge{
  padding:3px 8px;border-radius:12px;font-size:11px;
  background:rgba(110,168,254,0.1);color:rgba(110,168,254,0.7);
  border:1px solid rgba(110,168,254,0.15);
}
#ed-remove-session{
  padding:3px 8px;border-radius:12px;font-size:11px;
  background:rgba(255,100,100,0.08);color:rgba(255,100,100,0.6);
  border:1px solid rgba(255,100,100,0.12);cursor:pointer;
}
#editor-actions{
  display:flex;justify-content:flex-end;gap:8px;
  margin-top:12px;padding-top:12px;
  border-top:1px solid rgba(255,255,255,0.06);
}
#editor-actions button{
  background:rgba(255,255,255,0.08);border:none;
  color:rgba(255,255,255,0.7);font-size:13px;
  padding:6px 14px;border-radius:8px;cursor:pointer;font-family:inherit;
}
#editor-actions button:active{background:rgba(255,255,255,0.15)}
#editor-actions .save{color:#fff;background:rgba(255,255,255,0.15)}
#del-btn{color:rgba(255,100,100,0.8)}

/* â”€â”€â”€ Zero button â”€â”€â”€ */
#zero-btn{
  position:fixed;
  bottom:max(28px,calc(env(safe-area-inset-bottom,0px)+16px));
  right:20px;
  width:48px;height:48px;border-radius:50%;
  background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);
  display:flex !important;align-items:center;justify-content:center;
  cursor:pointer;z-index:90;
}
#zero-btn:active{background:rgba(255,255,255,0.12)}
#zero-btn:active{background:rgba(255,255,255,0.1)}
#zero-btn svg{width:18px;height:18px;opacity:0.3;pointer-events:none}
@keyframes zero-pulse{0%,100%{box-shadow:0 0 0 0 rgba(110,168,254,0)}50%{box-shadow:0 0 0 6px rgba(110,168,254,0.06)}}
#zero-btn{animation:zero-pulse 4s ease-in-out infinite}

/* â”€â”€â”€ Zero capture overlay â”€â”€â”€ */
#zero-overlay{
  position:fixed;inset:0;z-index:150;display:none;
  background:rgba(0,0,0,0.85);
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  flex-direction:column;align-items:center;justify-content:center;padding:24px;
}
#zero-overlay.open{display:flex}
#zero-overlay textarea{
  width:100%;max-width:480px;min-height:120px;max-height:50vh;
  background:transparent;border:none;outline:none;
  color:#fff;font-size:20px;line-height:1.6;
  font-family:inherit;resize:none;text-align:center;
  -webkit-user-select:text;user-select:text;
}
#zero-overlay textarea::placeholder{color:rgba(255,255,255,0.15)}
#zero-actions{display:flex;gap:12px;margin-top:24px}
#zero-actions button{
  background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);
  color:rgba(255,255,255,0.7);font-size:14px;padding:8px 20px;
  border-radius:10px;cursor:pointer;font-family:inherit;
}
#zero-actions button:active{background:rgba(255,255,255,0.15)}
#zero-actions .save{color:#fff;background:rgba(255,255,255,0.15);border-color:rgba(255,255,255,0.15)}

/* â”€â”€â”€ Folder bar (hidden â€“ sessions replaced folders) â”€â”€â”€ */
#folder-bar{
  position:fixed;
  top:max(38px,calc(env(safe-area-inset-top,0px)+24px));
  left:50%;transform:translateX(-50%);
  display:none !important;gap:6px;z-index:85;
  max-width:calc(100vw - 48px);
  overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;padding:2px 4px;
}
#folder-bar::-webkit-scrollbar{display:none}
#folder-bar .ftab{
  padding:5px 12px;border-radius:20px;font-size:12px;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.3);
  border:1px solid rgba(255,255,255,0.06);cursor:pointer;
  white-space:nowrap;flex-shrink:0;
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);transition:all 0.2s;
}
#folder-bar .ftab:active{background:rgba(255,255,255,0.08)}
#folder-bar .ftab.active{background:rgba(110,168,254,0.15);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.25)}

/* â”€â”€â”€ Session indicator (top center) â”€â”€â”€ */
/* â”€â”€â”€ Tag bar (hover to reveal) â”€â”€â”€ */
#tag-bar{
  position:fixed;top:0;left:0;right:0;
  background:rgba(10,10,15,0.95);backdrop-filter:blur(20px);
  padding:10px 16px;display:flex;gap:8px;align-items:center;
  z-index:100;transform:translateY(-100%);transition:transform 0.2s;
  border-bottom:1px solid rgba(255,255,255,0.06);
}
#tag-bar.show{transform:translateY(0)}
.tag-chip{
  padding:5px 11px;border-radius:16px;font-size:12px;
  background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.4);
  border:1px solid rgba(255,255,255,0.08);cursor:pointer;
  white-space:nowrap;transition:all 0.15s;
}
.tag-chip:hover{background:rgba(255,255,255,0.08)}
.tag-chip.active{background:rgba(110,168,254,0.15);color:rgba(110,168,254,0.9);border-color:rgba(110,168,254,0.3)}
.tag-chip.add-new{border-style:dashed;color:rgba(110,168,254,0.5)}

/* â”€â”€â”€ Session switcher button (top-left) â”€â”€â”€ */
#session-btn{
  position:fixed;
  top:max(16px,env(safe-area-inset-top,0px));
  left:16px;
  width:40px;height:40px;border-radius:10px;
  background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.1);
  display:flex !important;align-items:center;justify-content:center;
  cursor:pointer;z-index:90;
}
#session-btn:active{background:rgba(255,255,255,0.12)}
#session-btn:active{background:rgba(255,255,255,0.1)}
#session-btn svg{width:16px;height:16px;opacity:0.4;pointer-events:none}
#session-badge{
  position:absolute;top:-3px;right:-3px;
  min-width:14px;height:14px;border-radius:7px;
  background:rgba(110,168,254,0.8);color:#000;
  font-size:9px;font-weight:600;
  display:none;align-items:center;justify-content:center;padding:0 3px;
}
#session-badge.on{display:flex}

/* â”€â”€â”€ Session drawer (slide from left) â”€â”€â”€ */
#session-scrim{
  position:fixed;inset:0;z-index:9989;display:none;background:rgba(0,0,0,0.4);
}
#session-scrim.open{display:block}
#session-drawer{
  position:fixed;top:0;left:0;bottom:0;
  width:min(280px,80vw);
  background:rgba(10,10,15,0.97);
  border-right:1px solid rgba(255,255,255,0.08);
  z-index:9990;
  transform:translateX(-100%);
  transition:transform 0.25s cubic-bezier(0.32,0.72,0,1);
  display:flex;flex-direction:column;
  padding:max(16px,env(safe-area-inset-top,0px)) 0 max(16px,env(safe-area-inset-bottom,0px));
  overflow-y:auto;-webkit-overflow-scrolling:touch;
}
#session-drawer.open{transform:translateX(0)}
#session-drawer-title{
  font-size:13px;color:rgba(255,255,255,0.3);letter-spacing:0.08em;
  padding:8px 16px 12px;text-transform:uppercase;
}
.sd-item{
  display:flex;align-items:center;gap:10px;
  padding:12px 16px;cursor:pointer;transition:background 0.15s;
  border:none;background:none;width:100%;text-align:left;font-family:inherit;
}
.sd-item:active{background:rgba(255,255,255,0.05)}
.sd-item.active{background:rgba(110,168,254,0.08)}
.sd-thumb{
  width:48px;height:48px;border-radius:8px;
  background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
  flex-shrink:0;
}
.sd-item.active .sd-thumb{border-color:rgba(110,168,254,0.3)}
.sd-info{flex:1;min-width:0}
.sd-name{font-size:14px;color:rgba(255,255,255,0.75);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.sd-item.all-item .sd-name{color:rgba(255,255,255,0.45)}
.sd-meta{font-size:11px;color:rgba(255,255,255,0.2);margin-top:2px}
.sd-count{
  font-size:11px;color:rgba(255,255,255,0.2);flex-shrink:0;
  min-width:20px;text-align:right;
}
.sd-rename{
  width:28px;height:28px;border-radius:6px;border:none;
  background:rgba(110,168,254,0.08);color:rgba(110,168,254,0.5);
  font-size:14px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;
  margin-right:6px;
}
.sd-rename:active{background:rgba(110,168,254,0.2)}
.sd-delete{
  width:28px;height:28px;border-radius:6px;border:none;
  background:rgba(255,100,100,0.08);color:rgba(255,100,100,0.5);
  font-size:14px;cursor:pointer;flex-shrink:0;display:flex;align-items:center;justify-content:center;
}
.sd-delete:active{background:rgba(255,100,100,0.2)}
#sd-new-session{
  display:flex;align-items:center;gap:8px;
  padding:14px 16px;cursor:pointer;border:none;background:none;
  color:rgba(110,168,254,0.6);font-size:14px;font-family:inherit;
  width:100%;text-align:left;margin-top:auto;
  border-top:1px solid rgba(255,255,255,0.05);
}
#sd-new-session:active{background:rgba(255,255,255,0.03)}
/* â”€â”€â”€ Drawer utility section â”€â”€â”€ */
#sd-utils{
  border-top:1px solid rgba(255,255,255,0.06);
  padding:8px 0 0;margin-top:8px;
}
#sd-utils button{
  display:flex;align-items:center;
  width:100%;text-align:left;background:none;border:none;
  color:rgba(255,255,255,0.4);font-size:13px;
  padding:11px 16px;cursor:pointer;font-family:inherit;
}
#sd-utils button:active{background:rgba(255,255,255,0.05)}
#sd-utils .sd-util-danger{color:rgba(255,100,100,0.5)}
#sd-utils .sd-util-sep{
  margin:4px 16px;font-size:10px;color:rgba(255,255,255,0.12);
  letter-spacing:0.1em;text-transform:uppercase;
}
#sd-utils .toggle-dot{width:7px;height:7px;border-radius:50%;background:rgba(255,255,255,0.15);margin-left:auto;flex-shrink:0}
#sd-utils .toggle-dot.on{background:rgba(110,168,254,0.8)}
/* inline rename input */
.sd-rename-input{
  background:transparent;border:none;border-bottom:1px solid rgba(110,168,254,0.3);
  color:#fff;font-size:14px;padding:0 0 2px;outline:none;width:100%;font-family:inherit;
  -webkit-user-select:text;user-select:text;
}

/* â”€â”€â”€ Connection delete pill â”€â”€â”€ */
#conn-delete-pill{
  position:fixed;display:none;z-index:110;
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,100,100,0.2);
  border-radius:10px;padding:6px 14px;cursor:pointer;
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  color:rgba(255,100,100,0.8);font-size:13px;font-family:inherit;
  transform:translate(-50%,-100%) translateY(-8px);
}
#conn-delete-pill.open{display:block}
#conn-delete-pill:active{background:rgba(255,50,50,0.15)}

/* â”€â”€â”€ Lasso â”€â”€â”€ */
#lasso-rect{position:fixed;display:none;z-index:70;border:1px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.03);pointer-events:none;border-radius:2px}
#lasso-bar{
  position:fixed;display:none;z-index:110;
  bottom:max(80px,calc(env(safe-area-inset-bottom,0px)+70px));
  left:50%;transform:translateX(-50%);
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:6px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);display:none;gap:4px;
}
#lasso-bar.open{display:flex}
#lasso-bar button{
  background:rgba(255,255,255,0.06);border:none;color:rgba(255,255,255,0.7);
  font-size:13px;padding:7px 14px;border-radius:8px;cursor:pointer;font-family:inherit;white-space:nowrap;
}
#lasso-bar button:active{background:rgba(255,255,255,0.12)}
#lasso-folder-picker{
  position:fixed;display:none;z-index:115;
  bottom:max(130px,calc(env(safe-area-inset-bottom,0px)+120px));
  left:50%;transform:translateX(-50%);
  background:rgba(10,10,15,0.95);border:1px solid rgba(255,255,255,0.1);
  border-radius:12px;padding:8px;
  backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
  gap:6px;flex-wrap:wrap;max-width:80vw;justify-content:center;
}
#lasso-folder-picker.open{display:flex}

/* â”€â”€â”€ Stats (hidden â€“ vanity metric) â”€â”€â”€ */
#stats{
  display:none;
}
/* â”€â”€â”€ FPS â”€â”€â”€ */
#fps{
  position:fixed;top:max(16px,env(safe-area-inset-top,0px));right:16px;
  font-size:10px;color:rgba(255,255,255,0.2);
  font-variant-numeric:tabular-nums;pointer-events:none;display:none;z-index:85;
}
#fps.on{display:block}

/* â”€â”€â”€ Tray button (hidden â€“ merged into session drawer) â”€â”€â”€ */
#tray-btn{
  display:none !important;
}
#tray-btn svg{width:16px;height:16px;opacity:0.5;pointer-events:none}
/* â”€â”€â”€ Tray sheet (hidden â€“ merged into session drawer) â”€â”€â”€ */
#tray{
  display:none !important;
}
#tray.open{transform:translateY(0)}
#tray-handle{width:36px;height:4px;border-radius:2px;background:rgba(255,255,255,0.15);margin:0 auto 16px}
#tray button{
  display:flex;align-items:center;justify-content:space-between;
  width:100%;text-align:left;background:none;border:none;
  color:rgba(255,255,255,0.75);font-size:15px;
  padding:13px 12px;border-radius:10px;cursor:pointer;font-family:inherit;
}
#tray button:active{background:rgba(255,255,255,0.07)}
.toggle-dot{width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.15);flex-shrink:0}
.toggle-dot.on{background:rgba(110,168,254,0.8)}
.tray-sep{margin:4px 12px;font-size:10px;color:rgba(255,255,255,0.15);letter-spacing:0.1em;text-transform:uppercase}
#tray-scrim{position:fixed;inset:0;z-index:9998;display:none;background:transparent}
#tray-scrim.open{display:block}

/* â”€â”€â”€ Hint â”€â”€â”€ */
#hint{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:rgba(255,255,255,0.08);font-size:14px;pointer-events:none;transition:opacity 0.8s ease}
/* â”€â”€â”€ Toast â”€â”€â”€ */
#toast{
  position:fixed;top:max(16px,env(safe-area-inset-top,0px));
  left:50%;transform:translateX(-50%) translateY(-40px);
  background:rgba(255,255,255,0.1);border:1px solid rgba(255,255,255,0.1);
  border-radius:10px;padding:8px 16px;color:rgba(255,255,255,0.7);font-size:13px;
  backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);
  opacity:0;transition:all 0.3s ease;z-index:200;pointer-events:none;
}
#toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">tap anywhere</div>

<!-- Editor -->
<div id="editor">
  <textarea id="ed-text" placeholder="think..." autocomplete="off" autocorrect="on" spellcheck="true"></textarea>
  <button id="ed-color-btn" title="change color"></button>
  <div id="ed-color-palette"></div>
  <div id="ed-folder-row"></div>
  <div id="ed-session-row"></div>
  <div id="editor-actions">
    <button id="del-btn">delete</button>
    <button id="cancel-btn">cancel</button>
    <button class="save" id="save-btn">done</button>
  </div>
</div>

<!-- Zero button -->
<div id="zero-btn" aria-label="quick capture">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
</div>

<!-- Zero capture overlay -->
<div id="zero-overlay">
  <textarea id="zero-text" placeholder="what's on your mind?" autocomplete="off" autocorrect="on" spellcheck="true"></textarea>
  <div id="zero-actions">
    <button id="zero-cancel">cancel</button>
    <button class="save" id="zero-save">done</button>
  </div>
</div>

<!-- Session indicator (top center) -->
<!-- Tag bar (hover top to reveal) -->
<div id="tag-bar"></div>

<!-- Session switcher button (top-left) -->
<button id="session-btn">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <rect x="3" y="3" width="8" height="8" rx="1.5"/>
    <rect x="7" y="7" width="8" height="8" rx="1.5" opacity="0.5"/>
  </svg>
  <span id="session-badge"></span>
</button>

<!-- Session drawer -->
<div id="session-scrim"></div>
<div id="session-drawer">
  <div id="session-drawer-title">sessions</div>
  <div id="sd-list"></div>
  <button id="sd-new-session">+ new session</button>
  <div class="sd-util-sep">data</div>
  <button id="sd-export">ğŸ’¾ export thoughts</button>
  <button id="sd-import">ğŸ“‚ import thoughts</button>
  <div id="sd-utils">
    <button id="sd-open-capture">open to capture <span class="toggle-dot" id="sd-capture-dot"></span></button>
    <div class="sd-util-sep">dev</div>
    <button id="sd-reset-view">reset camera</button>
    <button id="sd-dump-state">dump state</button>
    <button id="sd-force-save">force save</button>
    <button id="sd-show-orphans">show orphans</button>
    <button id="sd-test-thought">add test thought</button>
    <button id="sd-toggle-fps">fps counter <span class="toggle-dot" id="sd-fps-dot"></span></button>
    <button id="sd-migrate">ğŸ“¦ move all to Session 1</button>
    <div class="sd-util-sep"></div>
    <button id="sd-clear" class="sd-util-danger">clear all</button>
  </div>
</div>

<!-- Folder bar -->
<div id="folder-bar"></div>
<!-- Connection delete pill -->
<div id="conn-delete-pill">remove</div>
<!-- Lasso -->
<div id="lasso-rect"></div>
<div id="lasso-bar">
  <button id="lasso-new-session-btn">new session</button>
  <button id="lasso-recolor-btn">recolor</button>
  <button id="lasso-clear-btn">clear</button>
</div>
<!-- Stats -->
<div id="stats"></div>
<!-- FPS -->
<div id="fps"></div>
<!-- Tray -->
<button id="tray-btn" aria-label="menu">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <line x1="4" y1="7" x2="20" y2="7"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="17" x2="20" y2="17"/>
  </svg>
</button>
<div id="tray-scrim"></div>
<div id="tray" role="menu">
  <div id="tray-handle"></div>
  <button id="btn-export">export thoughts</button>
  <button id="btn-import">import thoughts</button>
  <button id="btn-open-capture">open to capture <span class="toggle-dot" id="capture-toggle-dot"></span></button>
  <button id="btn-clear">clear all</button>
  <div class="tray-sep">dev</div>
  <button id="btn-reset-view">reset camera</button>
  <button id="btn-dump-state">dump state</button>
  <button id="btn-force-save">force save</button>
  <button id="btn-show-orphans">show orphans</button>
  <button id="btn-toggle-fps">fps counter <span class="toggle-dot" id="fps-dot"></span></button>
</div>
<div id="toast"></div>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// State
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let state = {
  thoughts: [], connections: [], folders: [],
  activeFolder: null, camera: null, openToCapture: false,
  sessions: [],        // v5: array of session objects
  activeSession: null  // v5: session ID or null
};

const SESSION_THRESHOLD = 15;

let editingId = null, editingFolder = null, editingColor = null;
let connectSource = null, holdTimer = null;
let isDragging = false, draggedMesh = null;
let dragOffset = new THREE.Vector3();
let pointerStart = { x:0, y:0 }, pointerMoved = false, holdTriggered = false;
let pendingLineMesh = null, hintVisible = true;
let showFps = false;
let lassoActive = false, lassoStart = null, lassoEnd = null;
let lassoHoldTimer = null, lassoHoldTriggered = false;
let selectedIds = new Set();
let pendingDeleteConnId = null;
let sessionTipShown = false;

const HOLD_MS = 350, DRAG_THRESH = 8, SPHERE_RADIUS = 0.35;
const raycaster = new THREE.Raycaster();
raycaster.params.Line = { threshold: 0.4 };
const pointer = new THREE.Vector2();
const plane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
const intersectPt = new THREE.Vector3();
const COLORS = ['#6ea8fe','#a78bfa','#f472b6','#34d399','#fbbf24','#fb923c','#f87171','#67e8f9'];
let colorIdx = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Scene
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.035);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 0, 18);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.enablePan = true; controls.panSpeed = 0.8;
controls.rotateSpeed = 0.5; controls.zoomSpeed = 0.8;
controls.minDistance = 0.5; controls.maxDistance = 200;

scene.add(new THREE.AmbientLight(0x404060, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(5,8,10); scene.add(dl);
const bl = new THREE.DirectionalLight(0x4466aa, 0.3); bl.position.set(-5,-3,-8); scene.add(bl);

const sg = new THREE.BufferGeometry(); const sv = [];
for(let i=0;i<400;i++) sv.push((Math.random()-.5)*100,(Math.random()-.5)*100,(Math.random()-.5)*100);
sg.setAttribute('position', new THREE.Float32BufferAttribute(sv,3));
scene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xffffff,size:0.08,transparent:true,opacity:0.3})));

const thoughtGroup = new THREE.Group(); scene.add(thoughtGroup);
const lineGroup = new THREE.Group(); scene.add(lineGroup);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Thought mesh
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 24, 18);

function makeThoughtMaterial(color) {
  return new THREE.MeshStandardMaterial({
    color: new THREE.Color(color||'#6ea8fe'),
    emissive: new THREE.Color(color||'#6ea8fe'),
    emissiveIntensity:0.15, roughness:0.4, metalness:0.1,
    transparent:true, opacity:0.9,
  });
}

function createLabel(text) {
  const c = document.createElement('canvas');
  c.width = 1024; c.height = 256;
  const ctx = c.getContext('2d');
  ctx.scale(2, 2);
  ctx.clearRect(0, 0, 512, 128);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
  ctx.font = '300 24px -apple-system, BlinkMacSystemFont, sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  let display = text || '';
  if (display.length > 50) display = display.slice(0, 48) + 'â€¦';
  const words = display.split(' ');
  let lines = [], line = '';
  for (const w of words) {
    const test = line ? line+' '+w : w;
    if (ctx.measureText(test).width > 460) { lines.push(line); line = w; }
    else line = test;
  }
  if (line) lines.push(line);
  if (lines.length > 3) lines = lines.slice(0,3);
  const lineH = 30;
  const startY = 64 - ((lines.length-1)*lineH)/2;
  lines.forEach((l,i) => ctx.fillText(l, 256, startY + i*lineH));
  const tex = new THREE.CanvasTexture(c); tex.needsUpdate = true;
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, opacity:0.85, depthTest:false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(3, 0.75, 1);
  sprite.position.y = -SPHERE_RADIUS - 0.5;
  return sprite;
}

function addThoughtMesh(t) {
  const mat = makeThoughtMaterial(t.color);
  const mesh = new THREE.Mesh(sphereGeo, mat);
  mesh.position.set(t.position[0], t.position[1], t.position[2]);
  mesh.userData = { id:t.id, baseEmissive:0.15, targetEmissive:0.15, targetOpacity:0.9, breath:Math.random()*Math.PI*2 };
  if (t.text) { const l = createLabel(t.text); l.name='label'; mesh.add(l); }
  thoughtGroup.add(mesh);
  return mesh;
}

function updateLabel(mesh, text) {
  const old = mesh.getObjectByName('label');
  if (old) mesh.remove(old);
  if (text) { const l = createLabel(text); l.name='label'; mesh.add(l); }
}

function getMesh(id) { return thoughtGroup.children.find(m => m.userData.id === id); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Connections
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function rebuildConnections() {
  while (lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  const pairs = {};
  for (const c of state.connections) { const key = [c.from, c.to].sort().join('|'); pairs[key] = (pairs[key]||0) + 1; }
  const drawn = new Set();
  for (const c of state.connections) {
    const key = [c.from, c.to].sort().join('|');
    if (drawn.has(key)) continue; drawn.add(key);
    const mA = getMesh(c.from), mB = getMesh(c.to);
    if (!mA || !mB) continue;
    const density = pairs[key]||1;
    const opacity = Math.min(0.2 + density*0.1, 0.7);
    const geo = new THREE.BufferGeometry().setFromPoints([mA.position.clone(), mB.position.clone()]);
    const mat = new THREE.LineBasicMaterial({ color:0x6ea8fe, transparent:true, opacity, linewidth:1 });
    const line = new THREE.Line(geo, mat);
    const firstConn = state.connections.find(x => [x.from, x.to].sort().join('|') === key);
    line.userData = { from:c.from, to:c.to, density, connKey:key, connId:firstConn?.id };
    lineGroup.add(line);
  }
}

function updateConnectionPositions() {
  for (const line of lineGroup.children) {
    const mA = getMesh(line.userData.from), mB = getMesh(line.userData.to);
    if (!mA || !mB) continue;
    const pos = line.geometry.attributes.position;
    pos.setXYZ(0, mA.position.x, mA.position.y, mA.position.z);
    pos.setXYZ(1, mB.position.x, mB.position.y, mB.position.z);
    pos.needsUpdate = true;
  }
}

pendingLineMesh = (() => {
  const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
  const mat = new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:0.3 });
  const line = new THREE.Line(geo, mat); line.visible = false; scene.add(line); return line;
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session helpers (v5)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getSession(id) { return state.sessions.find(s => s.id === id); }

function getActiveSession() { return state.activeSession ? getSession(state.activeSession) : null; }

function sessionsForThought(tId) {
  return state.sessions.filter(s => s.thoughtIds.has(tId));
}

function isSessionsVisible() { return state.thoughts.length >= SESSION_THRESHOLD; }

function relativeTime(ts) {
  const diff = Date.now() - ts;
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'just now';
  if (mins < 60) return mins + 'm ago';
  const hrs = Math.floor(mins / 60);
  if (hrs < 24) return hrs + 'h ago';
  const days = Math.floor(hrs / 24);
  if (days === 1) return 'yesterday';
  if (days < 30) return days + 'd ago';
  return Math.floor(days / 30) + 'mo ago';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Filtering (session + folder)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function isThoughtVisible(t) {
  // Session filter only (folders deprecated)
  if (state.activeSession) {
    const session = getActiveSession();
    if (session && !session.thoughtIds.has(t.id)) return false;
  }
  return true;
}

function applyFilter() {
  for (const mesh of thoughtGroup.children) {
    const t = state.thoughts.find(x => x.id === mesh.userData.id);
    if (!t) continue;
    const vis = isThoughtVisible(t);
    mesh.userData.targetOpacity = vis ? 0.9 : 0.04;
    mesh.userData.targetEmissive = vis ? 0.15 : 0.02;
    const label = mesh.getObjectByName('label');
    if (label) label.material.opacity = vis ? 0.85 : 0.03;
  }
  for (const line of lineGroup.children) {
    const tA = state.thoughts.find(x => x.id === line.userData.from);
    const tB = state.thoughts.find(x => x.id === line.userData.to);
    if (!tA || !tB) { line.visible = false; continue; }
    const bothVisible = isThoughtVisible(tA) && isThoughtVisible(tB);
    line.visible = bothVisible;
    line.material.opacity = bothVisible ? 0.25 : 0;
  }
  updateSessionUI();
}

function renderFolderBar() {
  // Deprecated - folders removed
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session UI (v5)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateSessionUI() {
  renderTagBar();
  const badge = document.getElementById('session-badge');
  if (state.sessions.length > 1) {
    badge.textContent = state.sessions.length;
    badge.classList.add('on');
  } else {
    badge.classList.remove('on');
  }
}

function renderTagBar() {
  const bar = document.getElementById('tag-bar');
  let html = `<span class="tag-chip${!state.activeSession?' active':''}" data-tag="__all__">all</span>`;
  
  for (const s of state.sessions) {
    const isActive = state.activeSession === s.id;
    html += `<span class="tag-chip${isActive?' active':''}" data-tag="${s.id}">${s.name}</span>`;
  }
  
  html += `<span class="tag-chip add-new" data-tag="__new__">+ tag</span>`;
  bar.innerHTML = html;
  
  // Single delegated click handler
  bar.onclick = (e) => {
    const chip = e.target.closest('.tag-chip');
    if (!chip) return;
    
    const tag = chip.dataset.tag;
    if (tag === '__new__') {
      // Add tag instantly
      const name = `Tag ${state.sessions.length + 1}`;
      const s = createSession(name, []);
      switchSession(s.id);
      renderTagBar();
      toast(`created "${name}" - rename in drawer`);
    } else if (tag === '__all__') {
      switchSession(null);
      renderTagBar();
    } else {
      switchSession(tag);
      renderTagBar();
    }
  };
}

function openSessionDrawer() {
  renderSessionList();
  updateDrawerCaptureToggle();
  document.getElementById('session-drawer').classList.add('open');
  document.getElementById('session-scrim').classList.add('open');
}

function closeSessionDrawer() {
  document.getElementById('session-drawer').classList.remove('open');
  document.getElementById('session-scrim').classList.remove('open');
}

function renderSessionList() {
  const list = document.getElementById('sd-list');
  let html = '';
  // "All thoughts" item
  const isAll = !state.activeSession;
  html += `<button class="sd-item all-item${isAll?' active':''}" data-sid="__all__">
    <canvas class="sd-thumb" width="48" height="48"></canvas>
    <span class="sd-info"><span class="sd-name">all thoughts</span></span>
    <span class="sd-count">${state.thoughts.length}</span>
  </button>`;
  // Sessions sorted by touched (most recent first)
  const sorted = [...state.sessions].sort((a,b) => b.touched - a.touched);
  for (const s of sorted) {
    const isActive = state.activeSession === s.id;
    html += `<div class="sd-item${isActive?' active':''}" data-sid="${s.id}">
      <canvas class="sd-thumb" width="48" height="48"></canvas>
      <span class="sd-info">
        <span class="sd-name">${s.name}</span>
        <span class="sd-meta">${relativeTime(s.touched)}</span>
      </span>
      <span class="sd-count">${s.thoughtIds.size}</span>
      <button class="sd-rename" data-rename="${s.id}" title="rename">âœ</button>
      <button class="sd-delete" data-del="${s.id}" title="delete">Ã—</button>
    </div>`;
  }
  list.innerHTML = html;

  // Render thumbnails
  renderSessionThumbnails();

  // Events
  list.querySelectorAll('.sd-item[data-sid]').forEach(el => {
    el.addEventListener('click', (e) => {
      if (e.target.closest('.sd-delete') || e.target.closest('.sd-rename')) return;
      const sid = el.dataset.sid;
      switchSession(sid === '__all__' ? null : sid);
      closeSessionDrawer();
    });
  });
  // Rename buttons
  list.querySelectorAll('.sd-rename').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sid = btn.dataset.rename;
      const s = getSession(sid);
      if (!s) return;
      
      const item = btn.closest('.sd-item');
      const nameEl = item.querySelector('.sd-name');
      nameEl.innerHTML = `<input class="sd-rename-input" value="${s.name}" maxlength="30">`;
      const inp = nameEl.querySelector('input');
      inp.focus(); inp.select();
      
      const commit = () => {
        const v = inp.value.trim();
        if (v) { s.name = v; s.touched = Date.now(); save(); }
        renderSessionList();
      };
      inp.addEventListener('blur', commit);
      inp.addEventListener('keydown', (ke) => {
        if (ke.key === 'Enter') { ke.preventDefault(); commit(); }
        if (ke.key === 'Escape') renderSessionList();
      });
    });
  });
  // Delete buttons
  list.querySelectorAll('.sd-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const sid = btn.dataset.del;
      const s = getSession(sid);
      if (s && s.thoughtIds.size > 0) {
        if (!confirm(`delete "${s.name}"? (${s.thoughtIds.size} thoughts will remain in all thoughts)`)) return;
      }
      deleteSession(sid);
      renderSessionList();
    });
  });
}

function renderSessionThumbnails() {
  const list = document.getElementById('sd-list');
  const items = list.querySelectorAll('.sd-item');
  
  items.forEach(item => {
    const canvas = item.querySelector('.sd-thumb');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const sid = item.dataset.sid;
    
    // Clear canvas
    ctx.clearRect(0, 0, 48, 48);
    
    // Get thoughts for this session
    let thoughts = [];
    if (sid === '__all__') {
      thoughts = state.thoughts;
    } else {
      const session = getSession(sid);
      if (session) {
        thoughts = state.thoughts.filter(t => session.thoughtIds.has(t.id));
      }
    }
    
    if (thoughts.length === 0) return;
    
    // Find bounds
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    thoughts.forEach(t => {
      minX = Math.min(minX, t.position[0]);
      maxX = Math.max(maxX, t.position[0]);
      minY = Math.min(minY, t.position[1]);
      maxY = Math.max(maxY, t.position[1]);
    });
    
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    const padding = 6;
    
    // Draw thoughts as dots
    thoughts.forEach(t => {
      const x = padding + ((t.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y = padding + ((t.position[1] - minY) / rangeY) * (48 - padding * 2);
      
      ctx.fillStyle = t.color || '#6ea8fe';
      ctx.beginPath();
      ctx.arc(x, y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw connections
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 0.5;
    state.connections.forEach(conn => {
      const tA = thoughts.find(t => t.id === conn.from);
      const tB = thoughts.find(t => t.id === conn.to);
      if (!tA || !tB) return;
      
      const x1 = padding + ((tA.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y1 = padding + ((tA.position[1] - minY) / rangeY) * (48 - padding * 2);
      const x2 = padding + ((tB.position[0] - minX) / rangeX) * (48 - padding * 2);
      const y2 = padding + ((tB.position[1] - minY) / rangeY) * (48 - padding * 2);
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    });
  });
}

function switchSession(sessionId) {
  state.activeSession = sessionId;
  if (sessionId) {
    const s = getSession(sessionId);
    if (s) s.touched = Date.now();
  }
  applyFilter(); save();
}

// Camera flight disabled - was causing zoom issues
function frameSessionThoughts(sessionId) {
  // Disabled for stability
}

function flyToPosition(x, y, z) {
  // Disabled for stability
}

function createSession(name, thoughtIds) {
  // Assign a hue and position based on session count
  const hue = (state.sessions.length * 137.5) % 360; // golden angle
  
  // Fibonacci sphere for even 3D distribution
  const i = state.sessions.length;
  const phi = Math.acos(1 - 2 * (i + 0.5) / Math.max(1, state.sessions.length + 1));
  const theta = Math.PI * (1 + Math.sqrt(5)) * i;
  const radius = 25; // distance from origin
  
  const s = {
    id: uid(),
    name: name || `Session ${state.sessions.length + 1}`,
    thoughtIds: new Set(thoughtIds || []),
    hue: hue,
    position: [
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta),
      radius * Math.cos(phi)
    ],
    created: Date.now(),
    touched: Date.now()
  };
  state.sessions.push(s);
  save();
  return s;
}

function deleteSession(sid) {
  state.sessions = state.sessions.filter(s => s.id !== sid);
  if (state.activeSession === sid) state.activeSession = null;
  applyFilter(); save();
}

// Session button
document.getElementById('session-btn').addEventListener('click', (e) => {
  e.stopPropagation(); openSessionDrawer();
});
// Scrim closes drawer
document.getElementById('session-scrim').addEventListener('click', closeSessionDrawer);
// New session from drawer
document.getElementById('sd-new-session').addEventListener('click', () => {
  const s = createSession();
  switchSession(s.id);
  closeSessionDrawer();
  toast(s.name);
  // Immediately open drawer for rename
  setTimeout(() => { openSessionDrawer(); }, 300);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Drawer utilities (merged from tray)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('sd-export').addEventListener('click', () => {
  const data = JSON.stringify({
    thoughts:state.thoughts, connections:state.connections, folders:state.folders,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  }, null, 2);
  const blob = new Blob([data],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=`atem-${new Date().toISOString().slice(0,10)}.json`;
  a.click(); URL.revokeObjectURL(url);
  closeSessionDrawer(); toast('exported');
});

document.getElementById('sd-import').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type='file'; input.accept='.json';
  input.onchange = (ev) => {
    const file = ev.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (r) => {
      try {
        const data = JSON.parse(r.target.result);
        if (data.thoughts) {
          while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
          while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
          state.thoughts=data.thoughts; state.connections=data.connections||[];
          state.folders=data.folders||[];
          state.sessions = (data.sessions||[]).map(s => ({ ...s, thoughtIds: new Set(s.thoughtIds||[]) }));
          for(const t of state.thoughts){if(t.folder===undefined)t.folder=null;}
          for(const t of state.thoughts) addThoughtMesh(t);
          rebuildConnections(); applyFilter(); save();
          toast('imported '+state.thoughts.length+' thoughts');
          if(state.thoughts.length>0) hideHint();
        }
      } catch(err){toast('import failed');}
    };
    reader.readAsText(file);
  };
  input.click(); closeSessionDrawer();
});

function updateDrawerCaptureToggle() {
  const dot = document.getElementById('sd-capture-dot');
  if (dot) dot.classList.toggle('on', !!state.openToCapture);
}

document.getElementById('sd-open-capture').addEventListener('click', () => {
  state.openToCapture=!state.openToCapture; updateDrawerCaptureToggle(); updateCaptureToggle(); save();
  toast(state.openToCapture?'will open to capture':'will open to board');
  closeSessionDrawer();
});

document.getElementById('sd-migrate').addEventListener('click', () => {
  if (!confirm('move all thoughts to Session 1?')) return;
  
  // Find or create Session 1
  let s1 = state.sessions.find(s => s.name === 'Session 1');
  if (!s1) {
    s1 = createSession('Session 1', []);
  }
  
  // Add all thoughts to Session 1
  state.thoughts.forEach(t => s1.thoughtIds.add(t.id));
  
  // Recolor all to Session 1 color
  const color = s1.hue !== undefined ? `hsl(${s1.hue}, 70%, 60%)` : COLORS[0];
  state.thoughts.forEach(t => {
    t.color = color;
    const mesh = getMesh(t.id);
    if (mesh) {
      mesh.material.color.set(color);
      mesh.material.emissive.set(color);
    }
  });
  
  save();
  renderSessionList();
  toast(`${state.thoughts.length} thoughts â†’ Session 1`);
  closeSessionDrawer();
});

document.getElementById('sd-clear').addEventListener('click', () => {
  if(!confirm('clear all thoughts?')) return;
  state.thoughts=[]; state.connections=[]; state.folders=[]; state.activeFolder=null;
  state.sessions=[]; state.activeSession=null;
  while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
  while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  renderFolderBar(); applyFilter(); save();
  closeSessionDrawer(); toast('cleared');
});

document.getElementById('sd-reset-view').addEventListener('click', () => { camera.position.set(0,0,18); controls.target.set(0,0,0); save(); closeSessionDrawer(); });
document.getElementById('sd-dump-state').addEventListener('click', () => {
  const dump = { ...state, sessions: state.sessions.map(s=>({...s,thoughtIds:Array.from(s.thoughtIds)})) };
  console.log(JSON.stringify(dump, null, 2));
  closeSessionDrawer(); toast('state â†’ console');
});
document.getElementById('sd-force-save').addEventListener('click', () => { save(); closeSessionDrawer(); toast('saved'); });
document.getElementById('sd-test-thought').addEventListener('click', () => {
  const x = (Math.random() - 0.5) * 10;
  const y = (Math.random() - 0.5) * 10;
  const z = (Math.random() - 0.5) * 5;
  const text = `test ${Date.now().toString(36)}`;
  createThought(x, y, z, text);
  closeSessionDrawer();
  toast('test thought added');
});
document.getElementById('sd-show-orphans').addEventListener('click', () => {
  const connected = new Set();
  for(const c of state.connections){connected.add(c.from);connected.add(c.to);}
  let count=0;
  for(const mesh of thoughtGroup.children){
    if(!connected.has(mesh.userData.id)){
      count++;
      mesh.material.emissive.set('#ff4444'); mesh.material.emissiveIntensity=0.8;
      setTimeout(()=>{
        const t=state.thoughts.find(x=>x.id===mesh.userData.id);
        if(t) mesh.material.emissive.set(t.color||'#6ea8fe');
        mesh.userData.targetEmissive=0.15;
      },1500);
    }
  }
  closeSessionDrawer(); toast(count+' orphan'+(count!==1?'s':''));
});
document.getElementById('sd-toggle-fps').addEventListener('click', () => {
  showFps=!showFps;
  document.getElementById('fps').classList.toggle('on', showFps);
  document.getElementById('sd-fps-dot').classList.toggle('on', showFps);
  closeSessionDrawer();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Persistence
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function save() {
  state.camera = {
    px:camera.position.x,py:camera.position.y,pz:camera.position.z,
    tx:controls.target.x,ty:controls.target.y,tz:controls.target.z
  };
  // Serialize sessions (Set â†’ Array)
  const serializable = {
    ...state,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  };
  try { localStorage.setItem('atem-state', JSON.stringify(serializable)); } catch(e){}
}

function load() {
  try {
    const raw = localStorage.getItem('atem-state');
    if (!raw) {
      // No data - show import hint
      setTimeout(() => {
        if (state.thoughts.length === 0) {
          toast('no data found - import your thoughts or start fresh', 5000);
        }
      }, 1000);
      return;
    }
    const s = JSON.parse(raw);
    state.thoughts = s.thoughts||[]; state.connections = s.connections||[];
    state.folders = s.folders||[]; state.activeFolder = s.activeFolder||null;
    state.openToCapture = s.openToCapture||false;
    // v5 migration
    state.sessions = (s.sessions||[]).map(sess => ({
      ...sess,
      thoughtIds: new Set(sess.thoughtIds || [])
    }));
    state.activeSession = s.activeSession || null;
    // Validate activeSession still exists
    if (state.activeSession && !getSession(state.activeSession)) {
      // Fall back to most recently touched
      if (state.sessions.length > 0) {
        const sorted = [...state.sessions].sort((a,b) => b.touched - a.touched);
        state.activeSession = sorted[0].id;
      } else {
        state.activeSession = null;
      }
    }
    if (s.camera) { camera.position.set(s.camera.px,s.camera.py,s.camera.pz); controls.target.set(s.camera.tx,s.camera.ty,s.camera.tz); }
    for (const t of state.thoughts) { if (t.folder===undefined) t.folder=null; }
    
    // Auto-migrate: move all orphaned thoughts to "Session 1"
    if (state.thoughts.length > 0 && state.sessions.length === 0) {
      const allIds = state.thoughts.map(t => t.id);
      const s1 = createSession('Session 1', allIds);
      state.activeSession = s1.id;
      toast('all thoughts moved to Session 1');
    }
    
    for (const t of state.thoughts) addThoughtMesh(t);
    rebuildConnections(); applyFilter(); updateCaptureToggle();
    if (state.thoughts.length > 0) hideHint();
  } catch(e) { console.warn('load failed', e); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRUD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function uid() { return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }

function createThought(x, y, z, text, color) {
  // Default color: if in session, use session's hue; otherwise cycle through palette
  let defaultColor;
  if (!color && state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      // Convert session hue to color
      defaultColor = `hsl(${sess.hue}, 70%, 60%)`;
    }
  }
  if (!defaultColor) defaultColor = COLORS[colorIdx++ % COLORS.length];
  
  const t = {
    id:uid(), text:text||'',
    position:[x,y,z],
    color: color || defaultColor,
    created:Date.now(), touched:Date.now(),
    folder: null // folders deprecated
  };
  state.thoughts.push(t);
  // Auto-add to active session
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess) { sess.thoughtIds.add(t.id); sess.touched = Date.now(); }
  }
  addThoughtMesh(t); applyFilter(); save(); hideHint();
  return t;
}

function updateThought(id, text, folder, color) {
  const t = state.thoughts.find(t => t.id===id);
  if (!t) return;
  t.text = text; t.touched = Date.now();
  if (folder !== undefined) t.folder = folder;
  if (color !== undefined) t.color = color;
  const mesh = getMesh(id);
  if (mesh) {
    updateLabel(mesh, text);
    if (color) { mesh.material.color.set(color); mesh.material.emissive.set(color); }
  }
  applyFilter(); save();
}

function deleteThought(id) {
  state.thoughts = state.thoughts.filter(t=>t.id!==id);
  state.connections = state.connections.filter(c=>c.from!==id&&c.to!==id);
  // v5: remove from all sessions
  for (const s of state.sessions) s.thoughtIds.delete(id);
  const mesh = getMesh(id);
  if (mesh) thoughtGroup.remove(mesh);
  rebuildConnections(); save();
}

function moveThought(id, x, y, z) {
  const t = state.thoughts.find(t=>t.id===id);
  if (t) { t.position=[x,y,z]; t.touched=Date.now(); }
}

function addConnection(fromId, toId) {
  if (fromId===toId) return;
  state.connections.push({ id:uid(), from:fromId, to:toId, created:Date.now() });
  rebuildConnections(); applyFilter(); save(); toast('connected');
}

function deleteConnection(connKey) {
  state.connections = state.connections.filter(c => [c.from,c.to].sort().join('|') !== connKey);
  rebuildConnections(); applyFilter(); save(); toast('disconnected');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Editor
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const editorEl = document.getElementById('editor');
const edText = document.getElementById('ed-text');

function renderEditorColors() {
  const btn = document.getElementById('ed-color-btn');
  const palette = document.getElementById('ed-color-palette');
  if (!btn || !palette) return;
  
  // Set button color to current editing color
  btn.style.background = editingColor;
  
  // Generate palette based on session
  let colors = COLORS;
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      colors = [
        `hsl(${sess.hue}, 70%, 60%)`,
        `hsl(${sess.hue}, 80%, 65%)`,
        `hsl(${sess.hue}, 60%, 55%)`,
        `hsl(${(sess.hue + 30) % 360}, 70%, 60%)`,
        `hsl(${(sess.hue - 30 + 360) % 360}, 70%, 60%)`,
        `hsl(${sess.hue}, 50%, 50%)`,
        `hsl(${sess.hue}, 90%, 70%)`,
        `hsl(${sess.hue}, 40%, 45%)`
      ];
    }
  }
  
  // Render palette
  palette.innerHTML = colors.map(c => 
    `<div class="ed-color-swatch" data-color="${c}" style="background:${c}"></div>`
  ).join('');
  
  // Toggle palette on button click
  btn.onclick = (e) => {
    e.stopPropagation();
    palette.classList.toggle('open');
  };
  
  // Select color from palette
  palette.querySelectorAll('.ed-color-swatch').forEach(swatch => {
    swatch.onclick = (e) => {
      e.stopPropagation();
      editingColor = swatch.dataset.color;
      btn.style.background = editingColor;
      palette.classList.remove('open');
      
      if (editingId) {
        const mesh = getMesh(editingId);
        if (mesh) {
          mesh.material.color.set(editingColor);
          mesh.material.emissive.set(editingColor);
        }
      }
    };
  });
  
  // Close palette when clicking outside
  document.addEventListener('click', () => palette.classList.remove('open'));
}

function renderEditorFolders() {
  // Deprecated - folders removed
}

function renderEditorSessions() {
  const row = document.getElementById('ed-session-row');
  if (!editingId) { row.innerHTML = ''; return; }
  const sessions = sessionsForThought(editingId);
  if (sessions.length === 0 && !state.activeSession) { row.innerHTML = ''; return; }
  let html = '';
  if (sessions.length > 0) {
    for (const s of sessions) html += `<span class="s-badge">${s.name}</span>`;
  }
  // Show "remove from session" if in active session
  if (state.activeSession) {
    const active = getActiveSession();
    if (active && active.thoughtIds.has(editingId)) {
      html += `<span id="ed-remove-session">remove from ${active.name}</span>`;
    }
  }
  row.innerHTML = html;
  const rmBtn = document.getElementById('ed-remove-session');
  if (rmBtn) {
    rmBtn.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      const active = getActiveSession();
      if (active) {
        active.thoughtIds.delete(editingId);
        active.touched = Date.now();
        save(); applyFilter();
        toast('removed from ' + active.name);
      }
      closeEditor(false);
    });
  }
}

function openEditor(id) {
  clearSelection(); closeConnDeletePill();
  editingId = id;
  const t = state.thoughts.find(t=>t.id===id);
  edText.value = t ? t.text : '';
  editingFolder = t ? (t.folder||null) : (state.activeFolder||null);
  editingColor = t ? t.color : COLORS[0];
  renderEditorColors(); renderEditorFolders(); renderEditorSessions();
  editorEl.classList.add('open'); controls.enabled=false;
  edText.style.height='auto';
  setTimeout(()=>{ edText.focus(); edText.selectionStart=edText.value.length; }, 50);
}

function closeEditor(doSave) {
  if (doSave && editingId) {
    const text = edText.value.trim();
    if (!text) deleteThought(editingId);
    else updateThought(editingId, text, editingFolder, editingColor);
  }
  editingId=null; editingFolder=null; editingColor=null;
  editorEl.classList.remove('open'); controls.enabled=true;
  renderFolderBar();
}

document.getElementById('save-btn').addEventListener('click',()=>closeEditor(true));
document.getElementById('cancel-btn').addEventListener('click',()=>{
  if (editingId) { const t=state.thoughts.find(t=>t.id===editingId); if(t&&!t.text) deleteThought(editingId); }
  closeEditor(false);
});
document.getElementById('del-btn').addEventListener('click',()=>{ if(editingId) deleteThought(editingId); closeEditor(false); });
edText.addEventListener('keydown',(e)=>{
  if(e.key==='Escape'){closeEditor(false);e.preventDefault();}
  if(e.key==='Enter'&&!e.shiftKey){closeEditor(true);e.preventDefault();}
});
edText.addEventListener('input',()=>{ edText.style.height='auto'; edText.style.height=Math.min(edText.scrollHeight,200)+'px'; });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Zero button
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const zeroOverlay = document.getElementById('zero-overlay');
const zeroText = document.getElementById('zero-text');

function openZeroCapture() {
  clearSelection(); closeConnDeletePill();
  zeroText.value=''; zeroOverlay.classList.add('open'); controls.enabled=false;
  setTimeout(()=>zeroText.focus(),80);
}
function closeZeroCapture(doSave) {
  if (doSave) {
    const text = zeroText.value.trim();
    if (text) {
      const c = controls.target.clone();
      c.x+=(Math.random()-.5)*3; c.y+=(Math.random()-.5)*3; c.z+=(Math.random()-.5)*1;
      createThought(c.x, c.y, c.z, text);
      toast('captured');
    }
  }
  zeroOverlay.classList.remove('open'); controls.enabled=true;
}

document.getElementById('zero-btn').addEventListener('pointerdown',(e)=>{ e.stopPropagation(); e.preventDefault(); openZeroCapture(); });
document.getElementById('zero-save').addEventListener('click',()=>closeZeroCapture(true));
document.getElementById('zero-cancel').addEventListener('click',()=>closeZeroCapture(false));
zeroText.addEventListener('keydown',(e)=>{
  if(e.key==='Escape'){closeZeroCapture(false);e.preventDefault();}
  if(e.key==='Enter'&&!e.shiftKey){closeZeroCapture(true);e.preventDefault();}
});
zeroText.addEventListener('input',()=>{ zeroText.style.height='auto'; zeroText.style.height=Math.min(zeroText.scrollHeight,300)+'px'; });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Connection delete pill
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const connPill = document.getElementById('conn-delete-pill');
function showConnDeletePill(x, y, connKey) { pendingDeleteConnId=connKey; connPill.style.left=x+'px'; connPill.style.top=y+'px'; connPill.classList.add('open'); }
function closeConnDeletePill() { pendingDeleteConnId=null; connPill.classList.remove('open'); }
connPill.addEventListener('pointerdown', (e) => { e.stopPropagation(); e.preventDefault(); if(pendingDeleteConnId) deleteConnection(pendingDeleteConnId); closeConnDeletePill(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Lasso select
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const lassoRect = document.getElementById('lasso-rect');
const lassoBar = document.getElementById('lasso-bar');

function clearSelection() {
  selectedIds.clear();
  lassoBar.classList.remove('open');
  lassoRect.style.display = 'none';
  for (const mesh of thoughtGroup.children) {
    const t = state.thoughts.find(x=>x.id===mesh.userData.id);
    if (t && isThoughtVisible(t)) mesh.userData.targetEmissive = 0.15;
  }
}

function updateLassoRect() {
  if (!lassoStart || !lassoEnd) return;
  const x = Math.min(lassoStart.x, lassoEnd.x), y = Math.min(lassoStart.y, lassoEnd.y);
  const w = Math.abs(lassoEnd.x - lassoStart.x), h = Math.abs(lassoEnd.y - lassoStart.y);
  lassoRect.style.display = 'block';
  lassoRect.style.left=x+'px'; lassoRect.style.top=y+'px';
  lassoRect.style.width=w+'px'; lassoRect.style.height=h+'px';
}

function finishLasso() {
  if (!lassoStart || !lassoEnd) { lassoRect.style.display='none'; return; }
  const x1=Math.min(lassoStart.x,lassoEnd.x), y1=Math.min(lassoStart.y,lassoEnd.y);
  const x2=Math.max(lassoStart.x,lassoEnd.x), y2=Math.max(lassoStart.y,lassoEnd.y);
  if (x2-x1 < 20 && y2-y1 < 20) { lassoRect.style.display='none'; return; }
  selectedIds.clear();
  for (const mesh of thoughtGroup.children) {
    const t = state.thoughts.find(x=>x.id===mesh.userData.id);
    if (!t || !isThoughtVisible(t)) continue;
    const sp = mesh.position.clone().project(camera);
    const sx = (sp.x+1)/2 * window.innerWidth, sy = (1-sp.y)/2 * window.innerHeight;
    if (sx>=x1 && sx<=x2 && sy>=y1 && sy<=y2) { selectedIds.add(t.id); mesh.userData.targetEmissive = 0.5; }
  }
  lassoRect.style.display = 'none';
  if (selectedIds.size > 0) { lassoBar.classList.add('open'); toast(selectedIds.size + ' selected'); }
}

document.getElementById('lasso-clear-btn').addEventListener('pointerdown',(e)=>{ e.stopPropagation(); e.preventDefault(); clearSelection(); });

// Lasso â†’ recolor selected
document.getElementById('lasso-recolor-btn').addEventListener('pointerdown',(e)=>{
  e.stopPropagation(); e.preventDefault();
  if (selectedIds.size === 0) return;
  
  // Use active session's base color, or first color in palette
  let color = COLORS[0];
  if (state.activeSession) {
    const sess = getActiveSession();
    if (sess && sess.hue !== undefined) {
      color = `hsl(${sess.hue}, 70%, 60%)`;
    }
  }
  
  // Recolor all selected thoughts
  for (const id of selectedIds) {
    updateThought(id, state.thoughts.find(t=>t.id===id)?.text, null, color);
    const mesh = getMesh(id);
    if (mesh) {
      mesh.material.color.set(color);
      mesh.material.emissive.set(color);
    }
  }
  
  save();
  toast(`${selectedIds.size} recolored`);
  clearSelection();
});

// Lasso â†’ new session
document.getElementById('lasso-new-session-btn').addEventListener('pointerdown',(e)=>{
  e.stopPropagation(); e.preventDefault();
  if (selectedIds.size === 0) return;
  const name = prompt('session name')?.trim();
  if (!name) return;
  const s = createSession(name, selectedIds);
  switchSession(s.id);
  toast(s.name + ' (' + s.thoughtIds.size + ')');
  clearSelection();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Raycast helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ndcFromEvent(e) {
  const x = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
  const y = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
  pointer.set((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
}

function hitThought(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const visible = thoughtGroup.children.filter(m => {
    const t = state.thoughts.find(x=>x.id===m.userData.id);
    return t && isThoughtVisible(t);
  });
  const hits = raycaster.intersectObjects(visible, false);
  return hits.length ? hits[0].object : null;
}

function hitLine(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const visibleLines = lineGroup.children.filter(l => l.visible);
  const hits = raycaster.intersectObjects(visibleLines, false);
  return hits.length ? hits[0].object : null;
}

function worldPosFromScreen(e) {
  ndcFromEvent(e);
  raycaster.setFromCamera(pointer, camera);
  const camDir = camera.getWorldDirection(new THREE.Vector3());
  plane.setFromNormalAndCoplanarPoint(camDir.negate(), controls.target);
  raycaster.ray.intersectPlane(plane, intersectPt);
  return intersectPt.clone();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pointer interaction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function pxFromEvent(e) { return { x: e.clientX??e.touches?.[0]?.clientX??0, y: e.clientY??e.touches?.[0]?.clientY??0 }; }

function isOverlayOpen() {
  return editorEl.classList.contains('open') || zeroOverlay.classList.contains('open');
}

function onPointerDown(e) {
  if (isOverlayOpen()) return;
  if (e.target !== canvas) return;
  if (e.touches && e.touches.length > 1) { clearHold(); return; }
  closeConnDeletePill();
  const px = pxFromEvent(e);
  pointerStart = px; pointerMoved = false; holdTriggered = false;
  isDragging = false; lassoActive = false; lassoHoldTriggered = false;
  const hit = hitThought(e);
  if (hit) {
    draggedMesh = hit;
    const wp = worldPosFromScreen(e);
    dragOffset.copy(draggedMesh.position).sub(wp);
    holdTimer = setTimeout(()=>{
      if (!pointerMoved) {
        holdTriggered = true;
        connectSource = draggedMesh.userData.id;
        draggedMesh.material.emissiveIntensity = 0.6;
        pendingLineMesh.visible = true;
        if (navigator.vibrate) navigator.vibrate(30);
      }
    }, HOLD_MS);
    controls.enabled = false;
  } else {
    draggedMesh = null;
    lassoStart = px;
    lassoHoldTimer = setTimeout(()=>{
      if (!pointerMoved) {
        lassoHoldTriggered = true; lassoActive = true;
        if (navigator.vibrate) navigator.vibrate(20);
      }
    }, HOLD_MS);
    controls.enabled = true;
  }
}

function onPointerMove(e) {
  if (isOverlayOpen()) return;
  if (e.touches && e.touches.length > 1) { clearHold(); clearTimeout(lassoHoldTimer); lassoActive=false; lassoRect.style.display='none'; return; }
  const px = pxFromEvent(e);
  const dx = px.x-pointerStart.x, dy = px.y-pointerStart.y;
  if (Math.sqrt(dx*dx+dy*dy) > DRAG_THRESH) pointerMoved = true;
  if (draggedMesh && !holdTriggered && pointerMoved) {
    clearTimeout(holdTimer); isDragging = true;
    const wp = worldPosFromScreen(e);
    draggedMesh.position.copy(wp.add(dragOffset));
    moveThought(draggedMesh.userData.id, draggedMesh.position.x, draggedMesh.position.y, draggedMesh.position.z);
    updateConnectionPositions();
  }
  if (holdTriggered && connectSource) {
    const srcMesh = getMesh(connectSource);
    if (srcMesh) {
      const wp = worldPosFromScreen(e);
      const pos = pendingLineMesh.geometry.attributes.position;
      pos.setXYZ(0, srcMesh.position.x, srcMesh.position.y, srcMesh.position.z);
      pos.setXYZ(1, wp.x, wp.y, wp.z);
      pos.needsUpdate = true;
    }
    const hit = hitThought(e);
    for (const child of thoughtGroup.children) {
      const t = state.thoughts.find(x=>x.id===child.userData.id);
      if (t && isThoughtVisible(t)) child.userData.targetEmissive = (hit===child && child.userData.id!==connectSource) ? 0.5 : 0.15;
    }
  }
  if (lassoActive && lassoHoldTriggered) { controls.enabled = false; lassoEnd = px; updateLassoRect(); }
}

function onPointerUp(e) {
  if (isOverlayOpen()) return;
  clearTimeout(holdTimer); clearTimeout(lassoHoldTimer);
  if (lassoActive && lassoHoldTriggered && lassoEnd) {
    finishLasso(); lassoActive=false; lassoHoldTriggered=false; lassoStart=null; lassoEnd=null;
    controls.enabled = true; return;
  }
  lassoActive=false; lassoHoldTriggered=false; lassoStart=null; lassoEnd=null; lassoRect.style.display='none';
  if (holdTriggered && connectSource) {
    pendingLineMesh.visible = false;
    const hit = hitThought(e);
    if (hit && hit.userData.id !== connectSource) addConnection(connectSource, hit.userData.id);
    const src = getMesh(connectSource);
    if (src) src.userData.targetEmissive = 0.15;
    for (const child of thoughtGroup.children) child.userData.targetEmissive = 0.15;
    connectSource = null; applyFilter();
  } else if (isDragging && draggedMesh) {
    save();
  } else if (draggedMesh && !pointerMoved) {
    openEditor(draggedMesh.userData.id);
  } else if (!draggedMesh && !pointerMoved) {
    if (selectedIds.size > 0) { clearSelection(); }
    else {
      const lineHit = hitLine(e);
      if (lineHit && lineHit.userData.connKey) {
        const px = pxFromEvent(e);
        showConnDeletePill(px.x, px.y, lineHit.userData.connKey);
      } else {
        const wp = worldPosFromScreen(e);
        const t = createThought(wp.x, wp.y, wp.z);
        openEditor(t.id);
      }
    }
  }
  draggedMesh = null; isDragging = false; holdTriggered = false; controls.enabled = true;
}

function clearHold() {
  clearTimeout(holdTimer); holdTriggered = false;
  if (connectSource) { const src = getMesh(connectSource); if (src) src.userData.targetEmissive = 0.15; connectSource = null; pendingLineMesh.visible = false; }
}

canvas.addEventListener('touchstart', onPointerDown, { passive:false });
canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); onPointerMove(e); }, { passive:false });
canvas.addEventListener('touchend', onPointerUp);
canvas.addEventListener('touchcancel', ()=>{ clearHold(); clearTimeout(lassoHoldTimer); lassoActive=false; lassoRect.style.display='none'; draggedMesh=null; isDragging=false; controls.enabled=true; });
canvas.addEventListener('mousedown', onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Tray
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const trayEl = document.getElementById('tray');
const trayBtn = document.getElementById('tray-btn');
const trayScrim = document.getElementById('tray-scrim');

function openTray() { trayEl.classList.add('open'); trayScrim.classList.add('open'); }
function closeTray() { trayEl.classList.remove('open'); trayScrim.classList.remove('open'); }

trayBtn.addEventListener('click', openTray);
trayScrim.addEventListener('click', closeTray);

document.getElementById('btn-export').addEventListener('click', () => {
  // v5: include sessions in export
  const data = JSON.stringify({
    thoughts:state.thoughts, connections:state.connections, folders:state.folders,
    sessions: state.sessions.map(s => ({ ...s, thoughtIds: Array.from(s.thoughtIds) }))
  }, null, 2);
  const blob = new Blob([data],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=`atem-${new Date().toISOString().slice(0,10)}.json`;
  a.click(); URL.revokeObjectURL(url);
  closeTray(); toast('exported');
});

document.getElementById('btn-import').addEventListener('click', () => {
  const input = document.createElement('input');
  input.type='file'; input.accept='.json';
  input.onchange = (ev) => {
    const file = ev.target.files[0]; if(!file) return;
    const reader = new FileReader();
    reader.onload = (r) => {
      try {
        const data = JSON.parse(r.target.result);
        if (data.thoughts) {
          while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
          while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
          state.thoughts=data.thoughts; state.connections=data.connections||[];
          state.folders=data.folders||[];
          // v5: import sessions
          state.sessions = (data.sessions||[]).map(s => ({ ...s, thoughtIds: new Set(s.thoughtIds||[]) }));
          for(const t of state.thoughts){if(t.folder===undefined)t.folder=null;}
          for(const t of state.thoughts) addThoughtMesh(t);
          rebuildConnections(); applyFilter(); save();
          toast('imported '+state.thoughts.length+' thoughts');
          if(state.thoughts.length>0) hideHint();
        }
      } catch(err){toast('import failed');}
    };
    reader.readAsText(file);
  };
  input.click(); closeTray();
});

function updateCaptureToggle() {
  const dot = document.getElementById('capture-toggle-dot');
  if (dot) dot.classList.toggle('on', !!state.openToCapture);
}
document.getElementById('btn-open-capture').addEventListener('click', () => {
  state.openToCapture=!state.openToCapture; updateCaptureToggle(); save();
  toast(state.openToCapture?'will open to capture':'will open to board');
  closeTray();
});

document.getElementById('btn-clear').addEventListener('click', () => {
  if(!confirm('clear all thoughts?')) return;
  state.thoughts=[]; state.connections=[]; state.folders=[]; state.activeFolder=null;
  state.sessions=[]; state.activeSession=null;
  while(thoughtGroup.children.length) thoughtGroup.remove(thoughtGroup.children[0]);
  while(lineGroup.children.length) lineGroup.remove(lineGroup.children[0]);
  renderFolderBar(); applyFilter(); save();
  closeTray(); toast('cleared');
});

document.getElementById('btn-reset-view').addEventListener('click', () => { camera.position.set(0,0,18); controls.target.set(0,0,0); save(); closeTray(); });
document.getElementById('btn-dump-state').addEventListener('click', () => {
  // Pretty print with Sets converted
  const dump = { ...state, sessions: state.sessions.map(s=>({...s,thoughtIds:Array.from(s.thoughtIds)})) };
  console.log(JSON.stringify(dump, null, 2));
  closeTray(); toast('state â†’ console');
});
document.getElementById('btn-force-save').addEventListener('click', () => { save(); closeTray(); toast('saved'); });
document.getElementById('btn-show-orphans').addEventListener('click', () => {
  const connected = new Set();
  for(const c of state.connections){connected.add(c.from);connected.add(c.to);}
  let count=0;
  for(const mesh of thoughtGroup.children){
    if(!connected.has(mesh.userData.id)){
      count++;
      mesh.material.emissive.set('#ff4444'); mesh.material.emissiveIntensity=0.8;
      setTimeout(()=>{
        const t=state.thoughts.find(x=>x.id===mesh.userData.id);
        if(t) mesh.material.emissive.set(t.color||'#6ea8fe');
        mesh.userData.targetEmissive=0.15;
      },1500);
    }
  }
  closeTray(); toast(count+' orphan'+(count!==1?'s':''));
});
document.getElementById('btn-toggle-fps').addEventListener('click', () => {
  showFps=!showFps;
  document.getElementById('fps').classList.toggle('on', showFps);
  document.getElementById('fps-dot').classList.toggle('on', showFps);
  closeTray();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Toast & Hint
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toast(msg) { const el=document.getElementById('toast'); el.textContent=msg; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),1800); }
function hideHint() { if(!hintVisible) return; hintVisible=false; const h=document.getElementById('hint'); h.style.opacity='0'; setTimeout(()=>h.style.display='none',800); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Stats & FPS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let fpsFrames=0, fpsLast=performance.now(), fpsValue=0;

function updateStats() {
  const el=document.getElementById('stats');
  const tc=state.thoughts.length, cc=state.connections.length;
  if(tc===0){el.textContent='';return;}
  let s=`${tc} thought${tc!==1?'s':''}`;
  if(cc>0) s+=` Â· ${cc} connection${cc!==1?'s':''}`;
  if(state.activeFolder) s+=` Â· ${state.activeFolder}`;
  // v5: show session-scoped count
  if(state.activeSession) {
    const sess = getActiveSession();
    if (sess) s = `${sess.thoughtIds.size} in session Â· ${tc} total`;
  }
  el.textContent=s;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Animation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const now=performance.now(); const dt=(now-lastTime)/1000; lastTime=now;
  fpsFrames++;
  if(now-fpsLast>=500){ fpsValue=Math.round(fpsFrames/((now-fpsLast)/1000)); fpsFrames=0; fpsLast=now; if(showFps) document.getElementById('fps').textContent=fpsValue+' fps'; }
  controls.update();
  for(const mesh of thoughtGroup.children){
    const ud=mesh.userData; ud.breath+=dt*0.8;
    if(!isDragging||mesh!==draggedMesh){ mesh.position.y+=Math.sin(ud.breath)*0.0003; mesh.position.x+=Math.cos(ud.breath*0.7)*0.0002; }
    const ce=mesh.material.emissiveIntensity; const te=ud.targetEmissive+Math.sin(ud.breath)*0.03; mesh.material.emissiveIntensity+=(te-ce)*0.1;
    const co=mesh.material.opacity; mesh.material.opacity+=(ud.targetOpacity-co)*0.08;
  }
  if(lineGroup.children.length>0) updateConnectionPositions();
  updateStats();
  renderer.render(scene, camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Resize
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Init
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

load();
animate();

// ALWAYS open to "all thoughts" view
state.activeSession = null;
applyFilter();

// Hover near top to show tag bar
let tagBarTimeout;
document.addEventListener('mousemove', (e) => {
  const tagBar = document.getElementById('tag-bar');
  if (e.clientY < 60) {
    tagBar.classList.add('show');
    clearTimeout(tagBarTimeout);
    tagBarTimeout = setTimeout(() => tagBar.classList.remove('show'), 2000);
  }
});

if(state.openToCapture) setTimeout(()=>openZeroCapture(),200);
setInterval(save,10000);
if('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').catch(()=>{});
console.log('atem v10.2 â€” working build');
</script>
</body>
</html>
